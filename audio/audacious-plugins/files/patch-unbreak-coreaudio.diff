--- src/coreaudio/coreaudio.cc
+++ src/coreaudio/coreaudio.cc	2025-08-02 21:50:02.000000000 +0800
@@ -42,6 +42,17 @@
 
 #include "audiodevice.h"
 
+struct RestartPlaybackContext {
+    int currentTime;
+};
+
+static void restart_playback_func(void *context) {
+    RestartPlaybackContext *ctx = static_cast<RestartPlaybackContext*>(context);
+    aud_drct_play();
+    aud_drct_seek(ctx->currentTime);
+    delete ctx;
+}
+
 class CoreAudioPlugin : public OutputPlugin {
 public:
     static const char about[];
@@ -308,10 +319,6 @@
     init();
     if (currentPosition > 0 && currentTime > 0)
     {
-        dispatch_block_t restart_playback = ^{
-            aud_drct_play();
-            aud_drct_seek(currentTime);
-        };
         if (coreAudioDevice && rate > 0 && aud_get_bool ("coreaudio", "bitperfect_mode"))
         {
             // set the rate before starting playback to avoid hickups
@@ -322,13 +329,16 @@
             // We use GCD to avoid a blocking wait (even if 400ms is hardly
             // noticeable when you're busy switching the default output device
             // via a system utility).
-            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.4 * NSEC_PER_SEC),
-                           dispatch_get_main_queue(), restart_playback);
+            RestartPlaybackContext *ctx = new RestartPlaybackContext;
+            ctx->currentTime = currentTime;
+
+            dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.4 * NSEC_PER_SEC));
+            dispatch_after_f(when, dispatch_get_main_queue(), ctx, restart_playback_func);
         }
         else
         {
-            // playback can be started immediately, just invoke the block.
-            restart_playback();
+            aud_drct_play();
+            aud_drct_seek(currentTime);
         }
     }
 }
