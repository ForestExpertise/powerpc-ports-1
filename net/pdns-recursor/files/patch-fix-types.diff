--- negcache.cc
+++ negcache.cc	2025-08-03 20:05:27.000000000 +0800
@@ -93,7 +93,9 @@
   // We we look how old the entry is, and increase d_servedStale accordingly, taking care not to overflow
   const time_t howlong = std::max(static_cast<time_t>(1), now - entry->d_ttd);
   const uint32_t extension = std::max(1U, std::min(entry->d_orig_ttl, s_serveStaleExtensionPeriod));
-  entry->d_servedStale = std::min(entry->d_servedStale + 1 + howlong / extension, static_cast<time_t>(s_maxServedStaleExtensions));
+  entry->d_servedStale = std::min<time_t>(
+    static_cast<time_t>(entry->d_servedStale + 1 + howlong / extension),
+    static_cast<time_t>(s_maxServedStaleExtensions));
   entry->d_ttd = now + std::min(entry->d_orig_ttl, s_serveStaleExtensionPeriod);
 
   if (qtype == QType::ENT) {

--- negcache.hh
+++ negcache.hh	2025-08-03 20:04:26.000000000 +0800
@@ -78,7 +78,7 @@
     {
       // We like to keep things in cache when we (potentially) should serve stale
       if (s_maxServedStaleExtensions > 0) {
-        return d_ttd + static_cast<time_t>(s_maxServedStaleExtensions) * std::min(s_serveStaleExtensionPeriod, d_orig_ttl) < now;
+        return d_ttd + static_cast<time_t>(s_maxServedStaleExtensions) * static_cast<time_t>(std::min(s_serveStaleExtensionPeriod, d_orig_ttl)) < now;
       }
       else {
         return d_ttd < now;

--- recursor_cache.hh
+++ recursor_cache.hh	2025-08-03 20:04:06.000000000 +0800
@@ -94,7 +94,7 @@
     {
       // We like to keep things in cache when we (potentially) should serve stale
       if (s_maxServedStaleExtensions > 0) {
-        return d_ttd + static_cast<time_t>(s_maxServedStaleExtensions) * std::min(s_serveStaleExtensionPeriod, d_orig_ttl) < now;
+        return d_ttd + static_cast<time_t>(s_maxServedStaleExtensions) * static_cast<time_t>(std::min(s_serveStaleExtensionPeriod, d_orig_ttl)) < now;
       }
       else {
         return d_ttd < now;

--- recursor_cache.cc
+++ recursor_cache.cc	2025-08-03 20:32:50.000000000 +0800
@@ -211,7 +211,9 @@
   // We look how old the entry is, and increase d_servedStale accordingly, taking care not to overflow
   const time_t howlong = std::max(static_cast<time_t>(1), now - entry->d_ttd);
   const uint32_t extension = std::max(1U, std::min(entry->d_orig_ttl, s_serveStaleExtensionPeriod));
-  entry->d_servedStale = std::min(entry->d_servedStale + 1 + howlong / extension, static_cast<time_t>(s_maxServedStaleExtensions));
+  entry->d_servedStale = std::min<time_t>(
+    static_cast<time_t>(entry->d_servedStale + 1 + howlong / extension),
+    static_cast<time_t>(s_maxServedStaleExtensions));
   entry->d_ttd = now + extension;
 
   pushRefreshTask(entry->d_qname, entry->d_qtype, entry->d_ttd, entry->d_netmask);

--- rec-snmp.cc
+++ rec-snmp.cc	2025-08-03 20:27:26.000000000 +0800
@@ -240,7 +240,7 @@
   s_statsMap[statOID[statOIDLength - 1]] = name.c_str();
   netsnmp_register_scalar(netsnmp_create_handler_registration(name.c_str(),
                                                               isStatDisabled(StatComponent::SNMP, name) ? handleDisabledCounter64Stats : handleCounter64Stats,
-                                                              statOID,
+                                                              (oid*)statOID,
                                                               statOIDLength,
                                                               HANDLER_CAN_RONLY));
 }
@@ -258,14 +258,14 @@
                             snmpTrapOID,
                             snmpTrapOIDLen,
                             ASN_OBJECT_ID,
-                            customTrapOID,
+                            (const u_char*)customTrapOID,
                             OID_LENGTH(customTrapOID) * sizeof(oid));
 
   snmp_varlist_add_variable(&varList,
                             trapReasonOID,
                             OID_LENGTH(trapReasonOID),
                             ASN_OCTET_STR,
-                            reason.c_str(),
+                            (const u_char*)reason.c_str(),
                             reason.size());
 
   return sendTrap(d_trapPipe[1], varList);

--- snmp-agent.hh
+++ snmp-agent.hh	2025-08-03 20:13:58.000000000 +0800
@@ -6,6 +6,7 @@
 #include <unistd.h>
 
 #ifdef HAVE_NET_SNMP
+#include <cstring> /* strcmp */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/definitions.h>
 #include <net-snmp/types.h>

--- snmp-agent.cc
+++ snmp-agent.cc	2025-08-03 20:41:26.000000000 +0800
@@ -36,7 +36,7 @@
   val64.low = value & 0xffffffff;
   snmp_set_var_typed_value(request->requestvb,
                            ASN_COUNTER64,
-                           &val64,
+                           reinterpret_cast<const u_char*>(&val64),
                            sizeof(val64));
   return SNMP_ERR_NOERROR;
 }
