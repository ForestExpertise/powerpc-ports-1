diff --git a/kdeui/CMakeLists.txt b/kdeui/CMakeLists.txt
index d6ec8b4..f70b92d 100644
--- a/kdeui/CMakeLists.txt
+++ b/kdeui/CMakeLists.txt
@@ -437,7 +441,7 @@ if(MINGW)
 endif(MINGW)
 
 if(Q_WS_MAC)
-   target_link_libraries(kdeui LINK_PRIVATE ${CARBON_LIBRARY})
+   target_link_libraries(kdeui LINK_PRIVATE ${CARBON_LIBRARY} "-framework AppKit")
    if (MAC_USE_OSXKEYCHAIN)
      target_link_libraries(kdeui LINK_PRIVATE ${SECURITY_LIBRARY})
    endif (MAC_USE_OSXKEYCHAIN)
diff --git a/kdeui/util/kwallet_mac.h b/kdeui/util/kwallet_mac.h
new file mode 100644
index 0000000..434cb46
--- /dev/null
+++ b/kdeui/util/kwallet_mac.h
@@ -0,0 +1,291 @@
+/* This file is part of the KDE project
+ *
+ * Copyright (C) 2002-2004 George Staikos <staikos@kde.org>
+ * Copyright (C) 2008 Michael Leupold <lemma@confuego.org>
+ * Copyright (C) 2010 Frank Osterfeld <osterfeld@kde.org>
+ * Copyright (C) 2014 René Bertin <rjvbertin@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _KWALLET_MAC_H
+
+template <typename T>
+class QSharedValue : public QSharedMemory
+{
+public:
+    QSharedValue()
+        : QSharedMemory()
+    {
+        // we aren't shared until attachOrCreate has been called.
+        isShared = isMaster = hasClientsCounter = false;
+        _value = NULL;
+    }
+    virtual ~QSharedValue()
+    {
+        if( _value ){
+            delete _value;
+            _value = NULL;
+        }
+        if( hasClientsCounter ){
+            setNrClients(-1, true);
+            hasClientsCounter = false;
+        }
+    }
+    virtual bool detach()
+    {
+        if( _value ){
+            delete _value;
+            _value = NULL;
+        }
+        if( hasClientsCounter ){
+            setNrClients(-1, true);
+            hasClientsCounter = false;
+        }
+        return QSharedMemory::detach();
+    }
+
+    virtual bool attachOrCreate(QSharedMemory::AccessMode mode=QSharedMemory::ReadWrite)
+    {
+        // attempt to create the QSharedMemory instance to avoid possible race conditions
+        // that could occur when trying to create one after trying first to attach to a
+        // preexisting instance.
+        bool ret = create( sizeof(T), mode );
+        if( ret ){
+            if( clientsCounter.create( sizeof(size_t), QSharedMemory::ReadWrite) ){
+                setNrClients(1, false);
+                hasClientsCounter = true;
+            }
+            else{
+                kWarning() << "QSharedValue::attachOrCreate" << key() << "cannot create clientsCounter"
+                    << clientsCounter.key() << ": " << clientsCounter.errorString();
+            }
+            isMaster = true;
+        }
+        else if( error() == QSharedMemory::AlreadyExists ){
+            // we are now sure that the segment exist, and that we should be able to attach to it
+            ret = attach(mode);
+            if( ret ){
+                if( clientsCounter.attach(QSharedMemory::ReadWrite) ){
+                    setNrClients(1, true);
+                    hasClientsCounter = true;
+                    kDebug() << "QSharedValue::attachOrCreate" << key() << "now has" << getNrClients() << "clients";
+                }
+                else{
+                    kWarning() << "QSharedValue::attachOrCreate" << key() << "cannot attach to clientsCounter"
+                        << clientsCounter.key() << ": " << clientsCounter.errorString();
+                }
+            }
+            isMaster = false;
+        }
+        if( !ret ){
+            _value = new T;
+            isShared = false;
+        }
+        else{
+            _value = NULL;
+            isShared = true;
+        }
+        return ret;
+    }
+    virtual bool attachOrCreate(QString &theKey, QSharedMemory::AccessMode mode=QSharedMemory::ReadWrite)
+    {
+        setKey(theKey);
+        // create a derived key for the client counter
+        clientsKey = QString::fromLatin1("clients of QSharedMemory ") + theKey;
+        clientsCounter.setKey(clientsKey);
+        return attachOrCreate(mode);
+    }
+    virtual bool attachOrCreate(QString &theKey, T *initVal, QSharedMemory::AccessMode mode=QSharedMemory::ReadWrite)
+    {
+        attachOrCreate( theKey, mode );
+        if( isMaster ){
+            setValue(initVal);
+        }
+        return isShared;
+    }
+    virtual bool attachOrCreate(QString &theKey, T initVal, QSharedMemory::AccessMode mode=QSharedMemory::ReadWrite)
+    {
+        return attachOrCreate( theKey, &initVal, mode );
+    }
+    virtual bool getValue(T &val)
+    {
+        if( isShared ){
+            if( lock() ){
+                T *dp = (T*)data();
+                bool ret;
+                if( dp ){
+                    val = *dp;
+                    ret = unlock();
+                }
+                else{
+                    unlock();
+                    ret = false;
+                }
+                return ret;
+            }
+            else{
+                return false;
+            }
+        }
+        else if( _value ){
+            val = *_value;
+            return true;
+        }
+        else{
+            return false;
+        }
+    }
+    virtual bool setValue(T *newVal)
+    {
+        if( isShared ){
+            if( lock() ){
+                T *dp = (T*)data();
+                bool ret;
+                if( dp ){
+                    *dp = *newVal;
+                    ret = unlock();
+                }
+                else{
+                    unlock();
+                    ret = false;
+                }
+                return ret;
+            }
+            else{
+                return false;
+            }
+        }
+        else if( _value ){
+            *_value = *newVal;
+            return true;
+        }
+        else{
+            return false;
+        }
+    }
+    virtual bool setValue(T newVal)
+    {
+        return setValue(&newVal);
+    }
+
+    // return the number of clients connected to this shared value
+    // The number includes the owner, so valid return values are positive.
+    size_t getNrClients()
+    {   size_t val = 0;
+        if( hasClientsCounter && clientsCounter.lock() ){
+            size_t *dp = (size_t*)clientsCounter.data();
+            if( dp ){
+                val = *dp;
+            }
+            clientsCounter.unlock();
+        }
+        return val;
+    }
+
+private:
+    // is this an actual shared resource or just a local store because the resource
+    // couldn't be created?
+    bool isShared;
+    // is this the "master" instance, the one that created the shared resource?
+    bool isMaster;
+    // local store in case isShared==false
+    T *_value;
+    // the number of clients connected, including the master/owner
+    QSharedMemory clientsCounter;
+    QString clientsKey;
+    bool hasClientsCounter;
+
+    bool setNrClients(size_t newVal, bool increment)
+    {
+        if( clientsCounter.lock() ){
+            size_t *dp = (size_t*)clientsCounter.data();
+            bool ret;
+            if( dp ){
+                if( increment ){
+                    *dp += newVal;
+                }
+                else{
+                    *dp = newVal;
+                }
+                ret = clientsCounter.unlock();
+            }
+            else{
+                clientsCounter.unlock();
+                ret = false;
+            }
+            return ret;
+        }
+        else{
+            return false;
+        }
+    }
+};
+
+namespace KWallet
+{
+
+#pragma mark ==== Wallet::WalletPrivate ====
+class Wallet::WalletPrivate : protected QObject, public OSXKeychain
+{
+    Q_OBJECT
+public:
+    explicit WalletPrivate(Wallet *wallet, const QString &n, int h);
+    virtual ~WalletPrivate();
+
+#ifndef USE_KWALLETD
+    void addToRegistry();
+    void removeFromRegistry();
+    QStringList getUsersFromRegistry();
+#endif //USE_KWALLETD
+
+    virtual void cleanup();
+    virtual void close();
+    OSStatus lock();
+
+    void deleteIdleTimer();
+
+    // This function is to be called at every operation that is supposed to launch or reset
+    // the idle timing.
+    void handleIdleTiming(const char *caller="", bool touchAccessTime=true);
+
+protected Q_SLOTS:
+    /**
+     * @internal
+     *  Received when a wallet's idle timer times out.
+     */
+    void slotIdleTimedOut();
+    void walletServiceUnregistered();
+
+public:
+    Wallet *q;
+    int handle;
+    bool isNew;
+    //! idle timeout in minutes
+    int timeOut;
+    QTimer *idleTimer;
+#ifdef IDLETIMER_DEBUG
+    size_t idleTimerTriggered;
+#endif
+    double lastConfigCheckTime;
+    QSharedValue<double> lastAccessTime;
+    friend class Wallet;
+};
+
+} // namespace KWallet
+
+#define _KWALLET_MAC_H
+#endif
\ No newline at end of file
diff --git a/kdeui/util/kwallet_mac.cpp b/kdeui/util/kwallet_mac.cpp
index 8344ebb..9bd8030 100644
--- a/kdeui/util/kwallet_mac.cpp
+++ b/kdeui/util/kwallet_mac.cpp
@@ -27,7 +27,9 @@
 #include <kdeversion.h>
 #include <QtGui/QApplication>
 #include <QtCore/QPointer>
+#include <QtCore/QSharedMemory>
 #include <QtGui/QWidget>
+#include <QtCore/QTimer>
 #include <ktoolinvocation.h>
 
 #include <kglobal.h>
@@ -39,9 +41,17 @@
 
 #include <sys/param.h>
 
+#define IDLETIMER_DEBUG
+#undef  REGISTRY_DEBUG
+#undef USE_KWALLETD
+
 #include "qosxkeychain.h"
 
-using namespace KWallet;
+#ifdef USE_KWALLETD
+#   include "kwallet_interface.h"
+#endif
+
+#include "kwallet_mac.h"
 
 typedef QMap<QString, QString> StringStringMap;
 Q_DECLARE_METATYPE(StringStringMap)
@@ -50,7 +60,87 @@ Q_DECLARE_METATYPE(StringToStringStringMapMap)
 typedef QMap<QString, QByteArray> StringByteArrayMap;
 Q_DECLARE_METATYPE(StringByteArrayMap)
 
-#ifdef OSX_KEYCHAIN_PORT_DISABLED
+#include <mach/mach.h>
+#include <mach/mach_time.h>
+#include <mach/mach_init.h>
+#include <sys/sysctl.h>
+
+static mach_timebase_info_data_t sTimebaseInfo;
+static double calibrator= 0, startTime = 0;
+static QSharedValue<double> sharedStartTime;
+
+double HRTime_Time()
+{
+    return mach_absolute_time() * calibrator - startTime;
+}
+
+void init_HRTime()
+{
+    if( !calibrator ){
+        mach_timebase_info(&sTimebaseInfo);
+        /* go from absolute time units to seconds (the timebase is calibrated in nanoseconds): */
+        calibrator= 1e-9 * sTimebaseInfo.numer / sTimebaseInfo.denom;
+        QString key = "kwalletWallClockStartTime";
+        sharedStartTime.attachOrCreate( key, HRTime_Time() );
+        sharedStartTime.getValue(startTime);
+        kDebug() << "init_HRTime(): connected to kwalletWallClock at t=" << HRTime_Time();
+    }
+}
+
+namespace KWallet
+{
+
+#ifdef USE_KWALLETD
+class KWalletDLauncher
+{
+public:
+    KWalletDLauncher();
+    ~KWalletDLauncher();
+    org::kde::KWallet &getInterface();
+
+    org::kde::KWallet *m_wallet;
+    KConfigGroup m_cgroup;
+};
+
+K_GLOBAL_STATIC(KWalletDLauncher, walletLauncher)
+static const char s_kwalletdServiceName[] = "org.kde.kwalletd";
+
+#else
+
+/**
+ * maps wallet name to a map of app name to <wallet,pid> instances
+ */
+// deserialising the WalletUsersList from a QDataStream works only for a few WalletInstancePtr types
+// We could store the Wallet* in a QByteArray, but that would make it impossible to dump the WalletUsersList
+// to the console for debugging. So we use a QVariant.
+typedef QVariant WalletInstancePtr;
+// typedef QList<QPair<WalletInstancePtr,pid_t> > WalletUsersListEntryData;
+class WalletUsersListEntryData : public QList<QPair<WalletInstancePtr,pid_t> >
+{
+public:
+    static WalletUsersListEntryData create(QPair<WalletInstancePtr,pid_t> &head)
+    {
+        WalletUsersListEntryData self;
+        self.clear();
+        self.append(head);
+        return self;
+    }
+    static WalletUsersListEntryData create(QPair<WalletInstancePtr,pid_t> head)
+    {
+        WalletUsersListEntryData self;
+        self.clear();
+        self.append(head);
+        return self;
+    }
+};
+
+typedef QMap<QString,WalletUsersListEntryData> WalletUsersListEntry;
+typedef QMap<QString,WalletUsersListEntry> WalletUsersList;
+static WalletUsersList walletUsers;
+
+#endif //USE_KWALLETD
+
+
 static QString appid()
 {
     KComponentData cData = KGlobal::mainComponent();
@@ -63,7 +153,6 @@ static QString appid()
     }
     return qApp->applicationName();
 }
-#endif
 
 /*static*/ const QString Wallet::LocalWallet()
 {
@@ -104,26 +193,307 @@ static QString appid()
     return "Form Data";
 }
 
+#ifndef USE_KWALLETD
+static QStringList getUsersFromRegistry(QString &name)
+{   QString app = appid();
+    QStringList users;
+    users.clear();
+    if( walletUsers.contains(name) ){
+        WalletUsersListEntry entry = walletUsers[name];
+        for( WalletUsersListEntry::const_iterator it = entry.constBegin() ; it != entry.constEnd() ; ++it ){
+            if( !it.value().isEmpty() ){
+                users.append(it.key());
+            }
+        }
+    }
+    return users;
+}
+
+static Wallet *findWalletUsedByAppInRegistry( const QString &wallet, const QString &app, pid_t owner=getpid() )
+{
+    Wallet *w = NULL;
+    // WalletUsersListEntryData entries = WalletUsersListEntryData::create(qMakePair(QVariant((qulonglong)q),getpid()));
+    if( walletUsers.contains(wallet) ){
+        WalletUsersListEntry walletClients = walletUsers[wallet];
+        if( walletClients.contains(app) ){
+            WalletUsersListEntryData appWalletClients = walletClients[app];
+            for( WalletUsersListEntryData::const_iterator it = appWalletClients.constBegin() ; it != appWalletClients.constEnd() && !w; ++it ){
+                QPair<WalletInstancePtr,pid_t> wdat = *it;
+                if( wdat.second == owner ){
+                    w = (Wallet*)(wdat.first.toULongLong());
+                    qDebug() << "## findWalletUsedByAppInRegistry() found" << w << wallet << "used by" << app << "pid=" << owner;
+                }
+            }
+        }
+    }
+    return w;
+}
+
+static void removeFromRegistry( QString app, QString &name, WalletUsersListEntryData &entries )
+{
+    for( WalletUsersListEntryData::const_iterator it = entries.constBegin() ; it != entries.constEnd() ; ++it ){
+        QPair<WalletInstancePtr,pid_t> wdat = *it;
+        if( walletUsers.contains(name) && walletUsers[name].contains(app) ){
+            WalletUsersListEntry entry = walletUsers[name];
+            WalletUsersListEntryData appInstances = entry[app];
+            if( appInstances.contains(wdat) ){
+                appInstances.removeAll(wdat);
+#ifdef REGISTRY_DEBUG
+                qDebug() << "removing application instance" << wdat << "from registry";
+#endif
+            }
+            if( appInstances.isEmpty() ){
+                entry.remove(app);
+#ifdef REGISTRY_DEBUG
+                qDebug() << "removing application" << app << "from registry";
+#endif
+            }
+            else{
+                entry[app] = appInstances;
+            }
+            if( entry[app].isEmpty() ){
+                walletUsers.remove(name);
+#ifdef REGISTRY_DEBUG
+                qDebug() << "removing wallet" << name << "from registry";
+#endif
+            }
+            else{
+                walletUsers[name] = entry;
+            }
+        }
+    }
+}
+#endif //USE_KWALLETD
+
 #pragma mark ==== Wallet::WalletPrivate ====
-class Wallet::WalletPrivate : public OSXKeychain
+Wallet::WalletPrivate::WalletPrivate(Wallet *wallet, const QString &n, int h)
+    : OSXKeychain(n, &isNew), q(wallet), handle(h)
+    , idleTimer(NULL)
+#ifdef IDLETIMER_DEBUG
+    , idleTimerTriggered(0)
+#endif
+    , lastConfigCheckTime(-1)
 {
-public:
-    explicit WalletPrivate(const QString &n)
-        : OSXKeychain(n)
-    {
-        isKDEChain = ( n == LocalWallet() || n == NetworkWallet() || n.contains( "wallet", Qt::CaseInsensitive ) );
+    isKDEChain = ( n == LocalWallet() || n == NetworkWallet() || n.contains( "wallet", Qt::CaseInsensitive ) );
+    if( !calibrator ){
+        init_HRTime();
     }
+    if( isKDEChain ){
+        if( !lastAccessTime.attachOrCreate( (QString&)n, QSharedMemory::ReadWrite) ){
+            kWarning() << "Couldn't create and/or attach to shared lastAccessTime member for wallet" << n
+                << "; idle timeouts will be per-client. Error" << lastAccessTime.errorString();
+        }
+        handleIdleTiming(__FUNCTION__);
+    }
+}
 
-    // needed for compilation reasons
-    void walletServiceUnregistered()
-    {
+Wallet::WalletPrivate::~WalletPrivate()
+{
+#ifndef USE_KWALLETD
+    removeFromRegistry();
+#endif //USE_KWALLETD
+    deleteIdleTimer();
+}
+
+#ifndef USE_KWALLETD
+void Wallet::WalletPrivate::addToRegistry()
+{   QString app = appid();
+    QPair<WalletInstancePtr,pid_t> wdat = qMakePair(QVariant((qulonglong)q),getpid());
+    if( !walletUsers.contains(name) ){
+        // Unknown wallet name, so there ought not be an existing QMap<appName,walletInstanceList>
+        WalletUsersListEntryData detail;
+        detail.clear();
+        detail.append(wdat);
+        WalletUsersListEntry entry;
+        entry.clear();
+        entry[app] = detail;
+        walletUsers[name] = entry;
     }
-};
+    else{
+        WalletUsersListEntry entry = walletUsers[name];
+        WalletUsersListEntryData detail;
+        if( entry.contains(app) ){
+            detail = entry[app];
+        }
+        else{
+            detail.clear();
+        }
+        detail.append(wdat);
+        entry[app] = detail;
+        walletUsers[name] = entry;
+    }
+    QByteArray mapData;
+    QDataStream ds(&mapData, QIODevice::WriteOnly);
+    ds << walletUsers;
+#ifdef REGISTRY_DEBUG
+    qDebug() << "@@@" << HRTime_Time() << "Added" << wdat << "for app" << app << "to wallet" << name << "in registry of len=" << mapData.length() << walletUsers;
+#endif
+}
+
+void Wallet::WalletPrivate::removeFromRegistry()
+{
+    WalletUsersListEntryData entries = WalletUsersListEntryData::create(qMakePair(QVariant((qulonglong)q),getpid()));
+    KWallet::removeFromRegistry( appid(), name, entries );
+}
+
+QStringList Wallet::WalletPrivate::getUsersFromRegistry()
+{
+    return KWallet::getUsersFromRegistry(name);
+}
+#endif //USE_KWALLETD
+
+void Wallet::WalletPrivate::cleanup()
+{
+    deleteIdleTimer();
+}
+
+void Wallet::WalletPrivate::close()
+{
+//     // close the keychain wallet but only if we get here through the kwalletmanager
+//     // or TODO if wallets should be closed when the last client disconnects
+//     // and we are the last client.
+//     if( appid() == "KDE Wallet Manager" ){
+        cleanup();
+        OSXKeychain::close();
+//     }
+}
+
+OSStatus Wallet::WalletPrivate::lock()
+{
+    if( idleTimer ){
+        idleTimer->stop();
+    }
+    return Lock(reference());
+}
+
+void Wallet::WalletPrivate::walletServiceUnregistered()
+{
+#ifdef USE_KWALLETD
+    if( handle >= 0 ){
+        q->slotWalletClosed(handle);
+    }
+#endif
+}
+
+void Wallet::WalletPrivate::deleteIdleTimer()
+{
+    if( idleTimer ){
+        idleTimer->stop();
+        disconnect( this, SLOT(slotIdleTimedOut()) );
+        idleTimer->deleteLater();
+        idleTimer = NULL;
+    }
+}
+
+// This function is to be called at every operation that is supposed to launch or reset
+// the idle timing.
+void Wallet::WalletPrivate::handleIdleTiming(const char *caller, bool touchAccessTime)
+{
+    if( !isKDEChain ){
+        return;
+    }
+    double now = HRTime_Time();
+    if( lastConfigCheckTime < 0 || (now - lastConfigCheckTime >= 10) ){
+        lastConfigCheckTime = now;
+        KConfigGroup cfg(KSharedConfig::openConfig("kwalletrc")->group("Wallet"));
+        if (cfg.readEntry("Close When Idle", true)) {
+            timeOut = cfg.readEntry( "Idle Timeout", ((int)0) );
+#ifdef IDLETIMER_DEBUG
+            if( caller && idleTimer ){
+                qDebug() << "###" << caller << "->handleIdleTiming: setting" << idleTimer << "for wallet" << name
+                    << "handle" << handle << "timeout to" << timeOut;
+            }
+#endif
+        }
+        else{
+            timeOut = -1;
+        }
+    }
+    if( timeOut >= 0 ){
+        if( !idleTimer ){
+            idleTimer = new QTimer(0);
+            if( idleTimer ){
+                connect( idleTimer, SIGNAL(timeout()), this, SLOT(slotIdleTimedOut()), Qt::DirectConnection );
+                idleTimer->setObjectName(QString::fromLatin1("idleTimer for process/wallet \"") + qAppName() + QString::fromLatin1("\"/") + name);
+#ifdef IDLETIMER_DEBUG
+                qDebug() << "###" << ((caller)? caller : "?") << "->handleIdleTiming: created" << idleTimer << "for wallet" << name
+                    << "handle" << handle << "timeout=" << timeOut;
+#endif
+            }
+        }
+        else{
+            idleTimer->stop();
+        }
+        // when the idle timer fires, the wallet is supposed to be closed. There is thus
+        // no reason to use a repeating timer.
+        idleTimer->setSingleShot(true);
+        if( touchAccessTime ){
+            // TODO: check HRTime_Time() in ms against INT_MAX and force a timeout on overflow?
+            if( !lastAccessTime.setValue(HRTime_Time()) ){
+                kWarning() << "Cannot set new lastAccessTime for wallet" << name << "error" << lastAccessTime.errorString();
+            }
+        }
+        int tO = timeOut * 60 * 1000;
+        if( tO > 0 ){
+            idleTimer->start(tO);
+        }
+        else{
+            if( sizeof(int) == 4 ){
+                idleTimer->start(INT32_MAX);
+            }
+            else{
+                idleTimer->start(INT64_MAX);
+            }
+        }
+    }
+    else{
+        timeOut = -1;
+        deleteIdleTimer();
+    }
+}
+
+void Wallet::WalletPrivate::slotIdleTimedOut()
+{   double lastTime = 0;
+    // check the last time anyone accessed this wallet:
+    if( !lastAccessTime.getValue(lastTime) ){
+        kWarning() << "Cannot get lastAccessTime for wallet" << name << "error" << lastAccessTime.errorString();
+        // don't leave lastTime==0!
+        lastTime = HRTime_Time();
+    }
+    // the time elapsed since that last access, in minutes:
+    double elapsed = (HRTime_Time() - lastTime) / 60;
+#ifdef IDLETIMER_DEBUG
+    idleTimerTriggered += 1;
+    qDebug() << "###" << HRTime_Time() << appid() << "Idle timeout" << timeOut << "min. for" << q << name << "handle" << handle
+        << "; elapsed minutes=" << elapsed << "timer" << idleTimer << "triggered" << idleTimerTriggered << "times; wallet isOpen=" << q->isOpen();
+#endif //IDLETIMER_DEBUG
+    if( elapsed >= timeOut || !q->isOpen() ){
+        // we have a true timeout, i.e. we didn't access the wallet in timeOut minutes, and no one else did either.
+        // or, the wallet was closed behind our backs, in which case we can just pretend we timed out unconditionally.
+        q->slotWalletClosed(handle);
+    }
+    else{
+        // false alarm, reset the timer, but there's no need to count this as an access!
+        handleIdleTiming(__FUNCTION__, false);
+    }
+}
 
 Wallet::Wallet(int handle, const QString& name)
-    : QObject(0L), d(new WalletPrivate(name))
+    : QObject(0L), d(new WalletPrivate(this, name, handle))
 {
-    Q_UNUSED(handle);
+#ifdef USE_KWALLETD
+    QDBusServiceWatcher *watcher = new QDBusServiceWatcher(QString::fromLatin1(s_kwalletdServiceName), QDBusConnection::sessionBus(),
+                                                           QDBusServiceWatcher::WatchForUnregistration, this);
+    connect(watcher, SIGNAL(serviceUnregistered(QString)),
+            d, SLOT(walletServiceUnregistered()));
+
+    connect(&walletLauncher->getInterface(), SIGNAL(walletClosed(int)), SLOT(slotWalletClosed(int)));
+    connect(&walletLauncher->getInterface(), SIGNAL(folderListUpdated(QString)), SLOT(slotFolderListUpdated(QString)));
+    connect(&walletLauncher->getInterface(), SIGNAL(folderUpdated(QString,QString)), SLOT(slotFolderUpdated(QString,QString)));
+    connect(&walletLauncher->getInterface(), SIGNAL(applicationDisconnected(QString,QString)), SLOT(slotApplicationDisconnected(QString,QString)));
+#else
+    d->addToRegistry();
+#endif // USE_KWALLETD
 }
 
 Wallet::~Wallet()
@@ -172,6 +542,9 @@ Wallet::~Wallet()
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     return walletLauncher->getInterface().isOpen(name); // default is false
 #else
+#ifdef USE_KWALLETD
+    walletLauncher->getInterface().isOpen(name);
+#endif // USE_KWALLETD
     return OSXKeychain::IsOpen(name);
 #endif
 }
@@ -181,6 +554,11 @@ bool Wallet::isOpen() const
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     return d->handle != -1;
 #else
+    d->handleIdleTiming(__FUNCTION__);
+
+#ifdef USE_KWALLETD
+    QDBusReply<bool> r = walletLauncher->getInterface().isOpen(d->name);
+#endif // USE_KWALLETD
     return d->isOpen();
 #endif
 }
@@ -193,7 +571,12 @@ bool Wallet::isOpen() const
     return r.isValid() ? r : -1;
 #else
     Q_UNUSED(force);
-    return OSXKeychain::Lock(name);
+#ifdef USE_KWALLETD
+    QDBusReply<int> r = walletLauncher->getInterface().close(name, force);
+#endif // USE_KWALLETD
+    // emit a signal that we just closed the wallet
+    Wallet(0, name).slotWalletClosed(0);
+    return OSXKeychain::IsOpen(name);
 #endif
 }
 
@@ -213,10 +596,30 @@ bool Wallet::isOpen() const
 {
     Q_UNUSED(w);
     Q_UNUSED(ot);
-    Wallet *wallet = new Wallet(-1, name);
-    QMetaObject::invokeMethod( wallet, "emitWalletOpened", Qt::QueuedConnection );
-    OSStatus err = wallet->d->unLock();
-    kDebug() << "Opened wallet '" << name << "': " << wallet << " error=" << err;
+    Wallet *wallet = new Wallet((int)w, name);
+    if( wallet ){
+#ifdef USE_KWALLETD
+        // connect the daemon's opened signal to the slot filtering the
+        // signals we need
+        connect(&walletLauncher->getInterface(), SIGNAL(walletAsyncOpened(int,int)),
+                wallet, SLOT(walletAsyncOpened(int,int)));
+#endif
+        if( !wallet->d->isOpen() ){
+            OSStatus err = wallet->d->unLock();
+            if( !err && wallet->d->isKDEChain && wallet->d->isNew ){
+                wallet->d->setLockSettings( false, 0 );
+            }
+            qDebug() << "Opened and unlocked wallet '" << name << "': " << wallet << " error=" << err;
+        }
+        else{
+            qDebug() << "Opened already unlocked wallet '" << name << "': " << wallet;
+        }
+#ifdef USE_KWALLETD
+        wallet->emitWalletOpened();
+#else
+        QMetaObject::invokeMethod( wallet, "emitWalletOpened", Qt::QueuedConnection );
+#endif
+    }
     return wallet;
 }
 
@@ -226,8 +629,37 @@ bool Wallet::isOpen() const
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     return walletLauncher->getInterface().disconnectApplication(wallet, app); // default is false
 #else
-    kWarning() << "Wallet::disconnectApplication unimplemented, '" << app << "' from '" << wallet << "'";
-    return true;
+#ifdef USE_KWALLETD
+    kWarning() << "Wallet::disconnectApplication unimplemented, '" << app << "' from '" << wallet << "'"
+        << walletLauncher->getInterface().disconnectApplication(wallet, app)
+    return false;
+#endif // USE_KWALLETD
+        ;
+    // app disconnect is done/possible only when the app in question closes its wallet.
+    Wallet *w = KWallet::findWalletUsedByAppInRegistry(wallet, app);
+    if( w ){
+        KConfigGroup cfg(KSharedConfig::openConfig("kwalletrc")->group("Wallet"));
+        if( w->d->lastAccessTime.getNrClients() == 1 && cfg.readEntry("Leave Open", true) ){
+            // check "close wallet when last client disconnects here, and
+            // if so, close it.
+            qDebug() << "### closing wallet" << w << wallet << "because the last client is disconnecting:" << app;
+            w->slotWalletClosed(w->d->handle);
+            return !OSXKeychain::IsOpen(wallet);
+        }
+        else{
+            qDebug() << "### Client" << app << "disconnecting from" << wallet << w << "; nr. clients=" << w->d->lastAccessTime.getNrClients();
+        }
+        w->d->handle = -1;
+        w->d->currentService.clear();
+        w->d->removeFromRegistry();
+        w->d->cleanup();
+        w->d->lastAccessTime.detach();
+        return true;
+    }
+    else{
+        qDebug() << "### No client" << app << "with pid=" << getpid() << "found to disconnect from wallet" << wallet;
+        return false;
+    }
 #endif
 }
 
@@ -237,8 +669,13 @@ bool Wallet::isOpen() const
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     return walletLauncher->getInterface().users(name); // default is QStringList()
 #else
-    kWarning() << "Wallet::users unimplemented, '" << name << "'";
-    return QStringList();
+#ifdef USE_KWALLETD
+    QStringList ul = walletLauncher->getInterface().users(name);
+    kWarning() << "Wallet::users unimplemented, '" << name << "'" << ul;
+    return ul;
+#else
+    return KWallet::getUsersFromRegistry((QString&)name);
+#endif // USE_KWALLETD
 #endif
 }
 
@@ -250,8 +687,12 @@ int Wallet::sync()
         return -1;
     }
 
-    walletLauncher->getInterface().sync(d->handle, appid());
 #endif
+    d->handleIdleTiming(__FUNCTION__);
+
+#ifdef USE_KWALLETD
+    walletLauncher->getInterface().sync(d->handle, appid());
+#endif // USE_KWALLETD
     return 0;
 }
 
@@ -272,13 +713,17 @@ int Wallet::lockWallet()
     }
 #else
     d->currentService.clear();
+    d->handle = -1;
 #endif
-    return d->lock();
+    d->lock();
+    emit walletClosed();
+    return 1;
 }
 
 
 const QString& Wallet::walletName() const
 {
+    d->handleIdleTiming(__FUNCTION__);
     return d->name;
 }
 
@@ -295,6 +740,7 @@ void Wallet::requestChangePassword(WId w)
     walletLauncher->getInterface().changePassword(d->name, (qlonglong)w, appid());
 #else
     Q_UNUSED(w);
+    d->handleIdleTiming(__FUNCTION__);
     kWarning() << "Wallet::requestChangePassword unimplemented '" << d->name << "'";
 #endif
 }
@@ -310,9 +756,17 @@ void Wallet::slotWalletClosed(int handle)
         emit walletClosed();
     }
 #else
-    Q_UNUSED(handle);
-    kWarning() << "Wallet::slotWalletClosed unimplemented '" << d->name << "'";
-    d->currentService.clear();
+    if( d->handle == handle ){
+        d->handle = -1;
+        d->currentService.clear();
+        kDebug() << "Wallet::slotWalletClosed '" << d->name << "'";
+        // TODO remove ourselves from the WalletUsersList here!
+        d->close();
+        emit walletClosed();
+    }
+    else{
+        kDebug() << "Wallet::slotWalletClosed '" << d->name << "' ignored because handle" << d->handle << "!=" << handle;
+    }
 #endif
 }
 
@@ -327,6 +781,7 @@ QStringList Wallet::folderList()
     QDBusReply<QStringList> r = walletLauncher->getInterface().folderList(d->handle, appid());
     return r;
 #else
+    d->handleIdleTiming(__FUNCTION__);
     return QStringList(d->folderList());
 #endif
 }
@@ -342,6 +797,8 @@ QStringList Wallet::entryList()
     QDBusReply<QStringList> r = walletLauncher->getInterface().entryList(d->handle, d->folder, appid());
     return r;
 #else
+    d->handleIdleTiming(__FUNCTION__);
+
     QStringList r = QStringList();
     d->itemList(r);
     return r;
@@ -359,6 +816,7 @@ bool Wallet::hasFolder(const QString& f)
     QDBusReply<bool> r = walletLauncher->getInterface().hasFolder(d->handle, f, appid());
     return r; // default is false
 #else
+    d->handleIdleTiming(__FUNCTION__);
     d->folderList();
     return d->serviceList.contains(f);
 #endif
@@ -379,6 +837,7 @@ bool Wallet::createFolder(const QString& f)
 
     return true;				// folder already exists
 #else
+    d->handleIdleTiming(__FUNCTION__);
     return setFolder(f);
 #endif
 }
@@ -407,6 +866,7 @@ bool Wallet::setFolder(const QString &f)
 
     return rc;
 #else
+    d->handleIdleTiming(__FUNCTION__);
     // act as if we just changed folders even if we have no such things; the property
     // is stored as the ServiceItemAttr (which shows up as the "Where" field in the Keychain Utility).
     if( f.size() == 0 ){
@@ -434,6 +894,7 @@ bool Wallet::removeFolder(const QString& f)
 
     return r;					// default is false
 #else
+    d->handleIdleTiming(__FUNCTION__);
     kWarning() << "Wallet::removeFolder unimplemented (returns true) '" << d->name << "'";
     if( d->currentService == f ){
         d->currentService.clear();
@@ -448,13 +909,16 @@ const QString& Wallet::currentFolder() const
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     return d->folder;
 #else
+    d->handleIdleTiming(__FUNCTION__);
     return d->currentService;
 #endif
 }
 
 
 int Wallet::readEntry(const QString &key, QByteArray &value)
-{   OSStatus err = d->readItem( key, &value, NULL );
+{   OSStatus err;
+    d->handleIdleTiming(__FUNCTION__);
+    err = d->readItem( key, &value, NULL );
     kDebug() << "Wallet::readEntry '" << key << "' from wallet " << d->name << ", error=" << ((err)? -1 : 0);
     return (err)? -1 : 0;
 }
@@ -485,6 +949,7 @@ int Wallet::readEntryList(const QString& key, QMap<QString, QByteArray>& value)
 #else
     Q_UNUSED(key);
     Q_UNUSED(value);
+    d->handleIdleTiming(__FUNCTION__);
     kWarning() << "Wallet::readEntryList unimplemented (returns -1) '" << d->name << "'";
     return -1;
 #endif
@@ -507,6 +972,7 @@ int Wallet::renameEntry(const QString& oldName, const QString& newName)
 
     return rc;
 #else
+    d->handleIdleTiming(__FUNCTION__);
     return d->renameItem( oldName, newName );
 #endif
 }
@@ -514,6 +980,8 @@ int Wallet::renameEntry(const QString& oldName, const QString& newName)
 
 int Wallet::readMap(const QString &key, QMap<QString,QString> &value)
 {
+    d->handleIdleTiming(__FUNCTION__);
+
     QByteArray v;
     const int ret = (d->readItem( key, &v, NULL ))? -1 : 0;
     if( ret != 0 ){
@@ -560,6 +1028,7 @@ int Wallet::readMapList(const QString& key, QMap<QString, QMap<QString, QString>
 #else
     Q_UNUSED(key);
     Q_UNUSED(value);
+    d->handleIdleTiming(__FUNCTION__);
     kWarning() << "Wallet::readMapList unimplemented (returns -1) '" << d->name << "'";
     return -1;
 #endif
@@ -568,6 +1037,8 @@ int Wallet::readMapList(const QString& key, QMap<QString, QMap<QString, QString>
 
 int Wallet::readPassword(const QString& key, QString& value)
 {
+    d->handleIdleTiming(__FUNCTION__);
+
     QByteArray ba;
     const int ret = (d->readItem( key, &ba, NULL ))? -1 : 0;
     if ( ret == 0 ){
@@ -582,18 +1053,23 @@ int Wallet::readPasswordList(const QString& key, QMap<QString, QString>& value)
 {
     Q_UNUSED(key);
     Q_UNUSED(value);
+    d->handleIdleTiming(__FUNCTION__);
     kWarning() << "Wallet::readPasswordList unimplemented (returns -1) '" << d->name << "'";
     return -1;
 }
 
 int Wallet::writeEntry(const QString& key, const QByteArray& password )
-{   int ret = d->writeItem( key, password );
+{   int ret;
+    d->handleIdleTiming(__FUNCTION__);
+    ret = d->writeItem( key, password );
     kDebug() << "wrote entry '" << key << "' to wallet " << d->name << ", error=" << ret;
     return ret;
 }
 
 int Wallet::writeEntry(const QString& key, const QByteArray& password, EntryType entryType)
 {
+    d->handleIdleTiming(__FUNCTION__);
+
     OSXKeychain::EntryType entryCode;
 	switch( entryType ){
 		case Wallet::Password:
@@ -616,6 +1092,8 @@ int Wallet::writeEntry(const QString& key, const QByteArray& password, EntryType
 
 int Wallet::writeMap(const QString& key, const QMap<QString,QString>& value)
 {
+    d->handleIdleTiming(__FUNCTION__);
+
     QByteArray mapData;
     QDataStream ds(&mapData, QIODevice::WriteOnly);
     ds << value;
@@ -630,7 +1108,10 @@ int Wallet::writeMap(const QString& key, const QMap<QString,QString>& value)
 
 
 int Wallet::writePassword(const QString &key, const QString& value)
-{   OSXKeychain::EntryType etype = OSXKeychain::Password;
+{   OSXKeychain::EntryType etype;
+
+    d->handleIdleTiming(__FUNCTION__);
+    etype = OSXKeychain::Password;
     int ret = d->writeItem( key, value.toUtf8(), &etype );
     kDebug() << "wrote password '" << key << "' to wallet " << d->name << ", error=" << ret;
     return ret;
@@ -638,13 +1119,19 @@ int Wallet::writePassword(const QString &key, const QString& value)
 
 
 bool Wallet::hasEntry(const QString &key)
-{   bool ret = d->hasItem( key, NULL );
+{   bool ret;
+
+    d->handleIdleTiming(__FUNCTION__);
+    ret = d->hasItem( key, NULL );
     kDebug() << "wallet '" << d->name << "'" << ((ret)? " has" : " does not have") << " entry '" << key << "'";
     return ret;
 }
 
 int Wallet::removeEntry(const QString& key)
-{   int ret = d->removeItem( key );
+{   int ret;
+
+    d->handleIdleTiming(__FUNCTION__);
+    ret = d->removeItem( key );
     kDebug() << "removed entry '" << key << "' from wallet " << d->name << ", error=" << ret;
     return ret;
 }
@@ -666,6 +1153,8 @@ Wallet::EntryType Wallet::entryType(const QString& key)
 
     return static_cast<EntryType>(rc);
 #else
+    d->handleIdleTiming(NULL);
+
     // RJVB: a priori, entries are always 'password' on OS X, but since we also do use them for storing
     // maps, it may be best to return Wallet::Unknown to leave some uncertainty and not mislead our caller.
     OSXKeychain::EntryType etype;
@@ -690,6 +1179,7 @@ Wallet::EntryType Wallet::entryType(const QString& key)
 void Wallet::slotFolderUpdated(const QString& wallet, const QString& folder)
 {
     if (d->name == wallet) {
+        kDebug() << "emit folderUpdated" << folder;
         emit folderUpdated(folder);
     }
 }
@@ -698,6 +1188,7 @@ void Wallet::slotFolderUpdated(const QString& wallet, const QString& folder)
 void Wallet::slotFolderListUpdated(const QString& wallet)
 {
     if (d->name == wallet) {
+        kDebug() << "emit foldeListrUpdated" << wallet;
         emit folderListUpdated();
     }
 }
@@ -705,17 +1196,19 @@ void Wallet::slotFolderListUpdated(const QString& wallet)
 
 void Wallet::slotApplicationDisconnected(const QString& wallet, const QString& application)
 {
-#ifdef OSX_KEYCHAIN_PORT_DISABLED
-    if (d->handle >= 0
+#ifdef USE_KWALLETD
+    qDebug() << "slotApplicationDisconnected(" << wallet << "," << application << "); handle="
+        << d->handle << "name=" << d->name << "appid=" << appid();
+    if( d->handle >= 0
         && d->name == wallet
-        && application == appid()) {
+        && application == appid()
+    ){
         slotWalletClosed(d->handle);
     }
 #else
     Q_UNUSED(wallet);
     Q_UNUSED(application);
-	kWarning() << "Wallet::slotApplicationDisconnected unimplemented '" << d->name << "'";
-#endif
+#endif //USE_KWALLETD
 }
 
 void Wallet::walletAsyncOpened(int tId, int handle)
@@ -733,23 +1226,33 @@ void Wallet::walletAsyncOpened(int tId, int handle)
     emit walletOpened(handle > 0);
 #else
     Q_UNUSED(tId);
-    Q_UNUSED(handle);
-	kWarning() << "Wallet::walletAsyncOpened unimplemented '" << d->name << "'";
+    d->handleIdleTiming(__FUNCTION__);
+#ifdef USE_KWALLETD
+    // disconnect the async signal
+    disconnect(this, SLOT(walletAsyncOpened(int,int)));
+    qDebug() << "walletAsyncOpened: emit walletOpened(true), handle=" << handle;
+    emit walletOpened(true);
+#endif // USE_KWALLETD
+    d->handle = handle;
 #endif
 }
 
 void Wallet::emitWalletAsyncOpenError()
 {
+    d->handleIdleTiming(__FUNCTION__);
+    kDebug() << "emitWalletAsyncOpenError: emit walletOpened(false)";
     emit walletOpened(false);
 }
 
 void Wallet::emitWalletOpened()
 {
-  emit walletOpened(true);
+    d->handleIdleTiming(__FUNCTION__);
+    kDebug() << "emitWalletOpened: emit walletOpened(true)";
+    emit walletOpened(true);
 }
 
 
-bool Wallet::folderDoesNotExist(const QString& wallet, const QString& folder)
+/*static*/ bool Wallet::folderDoesNotExist(const QString& wallet, const QString& folder)
 {
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     QDBusReply<bool> r = walletLauncher->getInterface().folderDoesNotExist(wallet, folder);
@@ -764,7 +1267,7 @@ bool Wallet::folderDoesNotExist(const QString& wallet, const QString& folder)
 }
 
 
-bool Wallet::keyDoesNotExist(const QString& wallet, const QString& folder, const QString& key)
+/*static*/ bool Wallet::keyDoesNotExist(const QString& wallet, const QString& folder, const QString& key)
 {
 #ifdef OSX_KEYCHAIN_PORT_DISABLED
     QDBusReply<bool> r = walletLauncher->getInterface().keyDoesNotExist(wallet, folder, key);
@@ -784,7 +1287,8 @@ bool Wallet::keyDoesNotExist(const QString& wallet, const QString& folder, const
 void Wallet::slotCollectionStatusChanged(int status)
 {
     Q_UNUSED(status);
-	kWarning() << "Wallet::slotCollectionStatusChanged unimplemented '" << d->name << "' status=" << status;
+    d->handleIdleTiming(__FUNCTION__);
+    kWarning() << "Wallet::slotCollectionStatusChanged unimplemented '" << d->name << "' status=" << status;
 }
 
 void Wallet::slotCollectionDeleted()
@@ -795,6 +1299,7 @@ void Wallet::slotCollectionDeleted()
     d->currentService.clear();
 #endif
     kDebug() << "Wallet::slotCollectionDeleted: closing private data '" << d->name;
+    // TODO remove ourselves from the WalletUsersList here!
     d->close();
     emit walletClosed();
 }
@@ -805,4 +1310,51 @@ void Wallet::virtual_hook(int, void*)
     //BASE::virtual_hook( id, data );
 }
 
+#ifdef USE_KWALLETD
+KWalletDLauncher::KWalletDLauncher()
+    : m_wallet(0),
+    m_cgroup(KSharedConfig::openConfig("kwalletrc", KConfig::NoGlobals)->group("Wallet"))
+{
+    m_wallet = new org::kde::KWallet(QString::fromLatin1(s_kwalletdServiceName), "/modules/kwalletd", QDBusConnection::sessionBus());
+}
+
+KWalletDLauncher::~KWalletDLauncher()
+{
+    delete m_wallet;
+}
+
+org::kde::KWallet &KWalletDLauncher::getInterface()
+{
+    Q_ASSERT(m_wallet != 0);
+
+    // check if kwalletd is already running
+    if (!QDBusConnection::sessionBus().interface()->isServiceRegistered(QString::fromLatin1(s_kwalletdServiceName)))
+    {
+        // not running! check if it is enabled.
+        bool walletEnabled = m_cgroup.readEntry("Enabled", true);
+        if (walletEnabled) {
+            // wallet is enabled! try launching it
+            QString error;
+            int ret = KToolInvocation::startServiceByDesktopPath("kwalletd.desktop", QStringList(), &error);
+            if (ret > 0){
+                kError(285) << "Couldn't start kwalletd: " << error << endl;
+            }
+
+            if (!QDBusConnection::sessionBus().interface()->isServiceRegistered(QString::fromLatin1(s_kwalletdServiceName))) {
+                kDebug(285) << "The kwalletd service is still not registered";
+            } else {
+                kDebug(285) << "The kwalletd service has been registered";
+            }
+        } else {
+            kError(285) << "The kwalletd service has been disabled";
+        }
+    }
+
+    return *m_wallet;
+}
+#endif //USE_KWALLETD
+
+} // namespace KWallet
+
+#include "kwallet_mac.moc"
 #include "kwallet.moc"
diff --git a/kdeui/util/qosxkeychain.h b/kdeui/util/qosxkeychain.h
index d0934e6..cad0bdc 100644
--- a/kdeui/util/qosxkeychain.h
+++ b/kdeui/util/qosxkeychain.h
@@ -18,6 +18,8 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#ifndef _QOSXKEYCHAIN_H
+
 #include <Security/Security.h>
 #include <Security/SecKeychain.h>
 
@@ -59,17 +61,23 @@ namespace {
 }
 
 static inline QString asQString( CFStringRef sr )
-{   CFIndex len = CFStringGetLength(sr)*2;
-    const CPPArrayDeleter<char*> buff(new char[len]);
-    if( CFStringGetCString( sr, buff.ptr, len, kCFStringEncodingUTF8 ) ){
-        return QString::fromUtf8(buff.ptr); //RJVB: use UTF8
-    }
-    else if( CFStringGetCString( sr, buff.ptr, len, kCFStringEncodingNonLossyASCII ) ){
-        return QString::fromLocal8Bit(buff.ptr);
+{
+    if( sr ){
+        CFIndex len = CFStringGetLength(sr)*2;
+        const CPPArrayDeleter<char*> buff(new char[len]);
+        if( CFStringGetCString( sr, buff.ptr, len, kCFStringEncodingUTF8 ) ){
+            return QString::fromUtf8(buff.ptr); //RJVB: use UTF8
+        }
+        else if( CFStringGetCString( sr, buff.ptr, len, kCFStringEncodingNonLossyASCII ) ){
+            return QString::fromLocal8Bit(buff.ptr);
+        }
+        else{
+            CFStringGetCString( sr, buff.ptr, len, kCFStringEncodingISOLatin1 );
+            return QString::fromLatin1(buff.ptr);
+        }
     }
     else{
-        CFStringGetCString( sr, buff.ptr, len, NULL );
-        return QString::fromLatin1(buff.ptr);
+        return QString();
     }
 }
 
@@ -87,8 +95,9 @@ static inline bool isError( OSStatus s, QString *errMsg )
     return s != 0;
 }
 
-class OSXKeychain
+class OSXKeychain //: protected QObject
 {
+//    Q_OBJECT
 private:
     SecKeychainRef keyChainRef;
     QString keyChainPath;
@@ -97,12 +106,13 @@ private:
 public:
 	enum EntryType { Unknown='K\?\?\?', Password='KPWD', Map='KMAP', Stream='KSTR' };
     QString name;
+    // KWallet folders correspond to OS X Keychain services
     QString currentService, lastReadService;
     QStringList serviceList;
     bool isKDEChain;
 
     OSXKeychain();
-    OSXKeychain(const QString &name);
+    OSXKeychain(const QString &name, bool *isNew=NULL);
     virtual ~OSXKeychain();
 
     inline SecKeychainRef reference()
@@ -119,54 +129,113 @@ public:
     }
     inline bool isOpen()
     {
-        return IsOpen(keyChainRef);
+        // we're either a KDE wallet/keychain and we have a valid keyChainRef,
+        // or we're not KDE and IsOpen will return the state of the default
+        // keychain if keyChainRef==NULL.
+        if( !isKDEChain || keyChainRef ){
+            return IsOpen(keyChainRef);
+        }
+        else{
+            return false;
+        }
     }
     inline OSStatus lock()
     {
-        return Lock(keyChainRef);
+        if( !isKDEChain || keyChainRef ){
+            return Lock(keyChainRef);
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus unLock()
     {
-        return UnLock(keyChainRef);
+        if( !isKDEChain || keyChainRef ){
+            return UnLock(keyChainRef);
+        }
+        else{
+            return 0;
+        }
     }
-    void close();
+    virtual void close();
+    OSStatus lockSettings(int &closeWhenIdle, unsigned int &idleTimeoutMin);
+    OSStatus setLockSettings(int closeWhenIdle, unsigned int idleTimeoutMin);
     inline bool hasItem(const QString &key, OSStatus *errReturn, SecKeychainItemRef *itemRef=NULL)
     {
-	    // qDebug() << "OSXKeychain::hasItem(" << key << "): scanning '" << name << "'=" << (void*) keyChainRef;
-	    return OSXKeychain::HasItem( key, keyChainRef, errReturn, itemRef );
+        if( !isKDEChain || keyChainRef ){
+            return OSXKeychain::HasItem( key, keyChainRef, errReturn, itemRef );
+        }
+        else{
+            return false;
+        }
     }
     inline OSStatus readItem(const QString &key, QByteArray *value, SecKeychainItemRef *itemRef=NULL)
     {
-        return ReadItem( key, value, keyChainRef, itemRef, this );
+        if( !isKDEChain || keyChainRef ){
+            return ReadItem( key, value, keyChainRef, itemRef, this );
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus itemType(const QString &key, EntryType *entryType)
     {
-        return ItemType( key, entryType, keyChainRef );
+        if( !isKDEChain || keyChainRef ){
+            return ItemType( key, entryType, keyChainRef );
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus removeItem(const QString &key)
     {
-        return RemoveItem( key, keyChainRef );
+        if( !isKDEChain || keyChainRef ){
+            return RemoveItem( key, keyChainRef );
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus writeItem( const QString &key, const QByteArray &value, EntryType *entryType=NULL )
     {
-        return WriteItem( key, value, keyChainRef, NULL, entryType, this );
+        if( !isKDEChain || keyChainRef ){
+            return WriteItem( key, value, keyChainRef, NULL, entryType, this );
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus writeItem( const QString &key, const QByteArray &value, const QString &comment,
                                EntryType *entryType=NULL )
     {
-        return WriteItem( key, value, comment, keyChainRef, entryType, this );
+        if( !isKDEChain || keyChainRef ){
+            return WriteItem( key, value, comment, keyChainRef, entryType, this );
+        }
+        else{
+            return 0;
+        }
     }
     inline OSStatus itemList( QStringList &keyList )
     {
-        return ItemList( keyChainRef, keyList, this );
+        if( !isKDEChain || keyChainRef ){
+            return ItemList( keyChainRef, keyList, this );
+        }
+        else{
+            return 0;
+        }
     }
     inline QStringList folderList()
     {
-        QStringList r;
-        CacheOldValue<bool> gFL(generateFolderList, true);
-        ItemList( keyChainRef, r, this );
-        r.clear();
-        return serviceList;
+        if( !isKDEChain || keyChainRef ){
+            QStringList r;
+            CacheOldValue<bool> gFL(generateFolderList, true);
+            ItemList( keyChainRef, r, this );
+            r.clear();
+            return serviceList;
+        }
+        else{
+            return QStringList();
+        }
     }
     OSStatus renameItem(const QString &currentKey, const QString &newKey);
 
@@ -197,4 +266,11 @@ public:
     static OSStatus ItemList( const SecKeychainRef keychain, QStringList &keyList, OSXKeychain *osxKeyChain=NULL );
     static OSStatus Destroy( SecKeychainRef *keychain );
     static OSStatus Destroy( const QString &walletName );
+
+// private Q_SLOTS:
+//     virtual void slotIdleTimedOut()
+//     {}
 };
+
+#define _QOSXKEYCHAIN_H
+#endif
\ No newline at end of file
diff --git a/kdeui/util/qosxkeychain.cpp b/kdeui/util/qosxkeychain.cpp
index 7cb9a22..caeb362 100644
--- a/kdeui/util/qosxkeychain.cpp
+++ b/kdeui/util/qosxkeychain.cpp
@@ -32,6 +32,7 @@ using namespace KWallet;
 #include "qosxkeychain.h"
 
 #include <CoreServices/CoreServices.h>
+#include <AvailabilityMacros.h>
 
 //! Define INTERNET_TOO=1 in order to build read-access to the kSecInternetPasswordItemClass items
 #define INTERNET_TOO    0
@@ -82,6 +83,24 @@ static QString keyChainName( SecKeychainRef keychain, QString *path=NULL )
     return keyFile.fileName();
 }
 
+// static inline QString serviceFromFolderAndAccount( const QString &folder, const QString &account )
+// {
+//     return folder + QString::fromLatin1("/") + account;
+// }
+//
+static inline QByteArray serviceFromFolderAndAccount( const QString *folder, const QByteArray &account )
+{
+    QString serviceName = *folder + QString::fromLatin1("/") + QString::fromUtf8(account);
+    return serviceName.toUtf8();
+}
+
+static inline QString folderFromService( SecKeychainAttribute &attr )
+{
+    QString serviceString = QString::fromUtf8( (char*)attr.data, attr.length );
+    QStringList foldertree = serviceString.split( "/", QString::SkipEmptyParts );
+    return (foldertree.size())? foldertree[0] : serviceString;
+}
+
 /*! Open an OS X keychain with name @p n.
  * OS X keychains can be created without a full path (say, "kdewallet"), in which case they
  * are stored e.g. as ~/Library/Keychains/kdewallet . However, opening a preexisting keychain like "login"
@@ -124,12 +143,13 @@ static OSStatus openKeychain( const QString &n, SecKeychainRef *keychain )
     return err;
 }
 
-static OSStatus basicWriteItem( const QByteArray *serviceName, const QByteArray &accountName, const QByteArray &value,
+static OSStatus basicWriteItem( const QString *serviceName, const QByteArray &accountName, const QByteArray &value,
                                const SecKeychainRef keychain, SecKeychainItemRef *itemRef=NULL )
 {   OSStatus err;
     QString errMsg;
     if( serviceName ){
-        err = SecKeychainAddGenericPassword( keychain, serviceName->size(), serviceName->constData(),
+        QByteArray service = serviceFromFolderAndAccount( serviceName, accountName );
+        err = SecKeychainAddGenericPassword( keychain, service.size(), service.constData(),
                                                      accountName.size(), accountName.constData(),
                                                      value.size(), value.constData(), itemRef );
     }
@@ -161,7 +181,7 @@ OSXKeychain::OSXKeychain()
     serviceList.append("");
 }
 
-OSXKeychain::OSXKeychain(const QString &n)
+OSXKeychain::OSXKeychain(const QString &n, bool *isNew)
     : name(n)
 {   QString errMsg;
     OSStatus err = openKeychain( n, &keyChainRef );
@@ -170,6 +190,57 @@ OSXKeychain::OSXKeychain(const QString &n)
         kWarning() << "Keychain '" << n << "' does not exist: attempting to create it";
         err = SecKeychainCreate( n.toUtf8(), 0, NULL, true, NULL, &keyChainRef );
         isKDEChain = true;
+        if( !err ){
+            if( isNew ){
+                *isNew = true;
+            }
+#if defined(__MAC_OS_X_VERSION_MAX_ALLOWED) && __MAC_OS_X_VERSION_MAX_ALLOWED >= 1090
+            // as of OS X 10.9, SecKeychainCreate no longer adds newly created keychains
+            // to the default search list ...
+            CFArrayRef list = NULL;
+            OSStatus err2 = SecKeychainCopySearchList(&list);
+            if( !isError( err2, &errMsg ) && list ){
+                CFIndex len = CFArrayGetCount(list), i;
+                CFMutableArrayRef newlist = CFArrayCreateMutable(NULL, len, &kCFTypeArrayCallBacks);
+                if( newlist ){
+                    QString systemKeyChain = QString::fromUtf8("/Library/Keychains/System.keychain");
+                    for( i = 0 ; i < len ; ++i ){
+                        SecKeychainRef keychain = (SecKeychainRef) CFArrayGetValueAtIndex( list, i );
+                        QString name = keyChainName(keychain);
+                        // we skip keychains without name (really, I used to have one), as well as the
+                        // System keychain which is always added automatically and would end up multiple
+                        // times in the list if we copied it too.
+                        if( name.size() > 0 && OSXKeychain::Path(keychain).compare(systemKeyChain) ){
+                            kDebug() << "Adding keychain" << name << "to a new keychain search list";
+                            CFArrayAppendValue( newlist, keychain );
+                        }
+                        else{
+                            kDebug() << "Skipping keychain" << name << "@" << OSXKeychain::Path(keychain);
+                        }
+                        // we do NOT release keychain here, that will be done when releasing the list
+                    }
+                    // append the newly created keychain
+                    CFArrayAppendValue( newlist, keyChainRef );
+                    // now replace the keychain search list
+                    err2 = SecKeychainSetSearchList(newlist);
+                    if( isError( err2, &errMsg ) ){
+                        kWarning() << "Error setting the new, appended keychain list:" << qPrintable(errMsg);
+                    }
+                    CFRelease(newlist);
+                }
+                else{
+                    kWarning() << "Error creating a new keychain list; new keychain will not be added to it";
+                }
+                CFRelease(list);
+            }
+            else{
+                kWarning() << "Error retrieving current keychain list; new keychain will not be added to it:" << qPrintable(errMsg);
+            }
+#endif
+        }
+    }
+    else if( !err && isNew ){
+        *isNew = false;
     }
 
     if( isError( err, &errMsg ) ){
@@ -197,14 +268,58 @@ OSXKeychain::OSXKeychain(const QString &n)
 void OSXKeychain::close()
 {
     if( keyChainRef ){
+        Lock(keyChainRef);
         CFRelease(keyChainRef);
         keyChainRef = NULL;
+        serviceList.clear();
     }
 }
 
 OSXKeychain::~OSXKeychain()
 {
-    close();
+    if( keyChainRef ){
+        CFRelease(keyChainRef);
+        keyChainRef = NULL;
+    }
+    serviceList.clear();
+}
+
+OSStatus OSXKeychain::lockSettings(int &closeWhenIdle, unsigned int &idleTimeoutMin)
+{   QString errMsg;
+    SecKeychainSettings kcSettings= { SEC_KEYCHAIN_SETTINGS_VERS1, 0, 0, INT_MAX };
+    OSStatus err = SecKeychainCopySettings( keyChainRef, &kcSettings );
+    if( isError( err, &errMsg ) ){
+        kWarning() << "Error getting settings for" << name << err << "=" << qPrintable(errMsg);
+    }
+    else{
+        closeWhenIdle = kcSettings.useLockInterval;
+        idleTimeoutMin = (int)(kcSettings.lockInterval / 60 + 0.5);
+    }
+    return err;
+}
+
+OSStatus OSXKeychain::setLockSettings(int closeWhenIdle, unsigned int idleTimeoutMin)
+{   QString errMsg;
+    SecKeychainSettings kcSettings = { SEC_KEYCHAIN_SETTINGS_VERS1, 0, 0, INT_MAX };
+    OSStatus err;
+
+    // to switch (or keep) off idle timeout locking set useLockInterval=false and lockInterval=INT_MAX
+    // if lockInterval has any other value, SecKeychainSetSettings() will force useLockInterval=true
+    if( closeWhenIdle ){
+        kcSettings.useLockInterval = 1;
+        kcSettings.lockInterval = idleTimeoutMin * 60;
+    }
+    err = SecKeychainSetSettings( keyChainRef, &kcSettings );
+//     if( !err ){
+//         SecKeychainSettings ks = { SEC_KEYCHAIN_SETTINGS_VERS1, 0, 0, INT_MAX };
+//         ks.useLockInterval = !closeWhenIdle;
+//         SecKeychainCopySettings( keyChainRef, &ks );
+//         qDebug() << "Keychain settings set to useLockInterval=" << ks.useLockInterval << "lockInterval=" << ks.lockInterval;
+//     }
+//     else{
+//         qDebug() << "Error setting keychain settings:" << err;
+//     }
+    return err;
 }
 
 OSStatus OSXKeychain::renameItem(const QString &currentKey, const QString &newKey)
@@ -303,6 +418,14 @@ OSStatus OSXKeychain::UnLock(const SecKeychainRef keychain)
         else{
             kDebug() << "Could not unlock the default keychain:"  << qPrintable(errMsg);
         }
+        if( IsOpen(keychain) ){
+            // this could happen when the user got presented with 2 unlock/passwords dialogs, unlocked the chain via the 2nd
+            // and then dismisses the 1st. It seems counter-productive to return the error code in that case; had we been
+            // called just an instant later SecKeychainUnlock() would have returned noErr without any other action because
+            // the chain was already unlocked.
+            qDebug() << "\tIgnoring error signalled above because keychain is (now) open";
+            err = noErr;
+        }
     }
     return err;
 }
@@ -330,7 +453,7 @@ OSStatus OSXKeychain::Lock(const QString &walletName)
     OSStatus err = openKeychain( walletName, &keychain );
     if( !err && keychain ){
         err = Lock(keychain);
-	   CFRelease(keychain);
+        CFRelease(keychain);
     }
     return err;
 }
@@ -377,7 +500,7 @@ bool OSXKeychain::HasItem(const QString &key,
 	        *errReturn = err;
 	    }
     }
-    kDebug() << ((found)? "Found" : "Did not find") << "item '" << key << "' in keychain " << (void*) keychain << ", error=" << err << " " << qPrintable(errMsg);
+    kDebug() << "item '" << key << ((found)? "found" : "not found") << "' in keychain " << (void*) keychain << ", error=" << err << " " << qPrintable(errMsg);
     return found;
 }
 
@@ -424,7 +547,8 @@ OSStatus OSXKeychain::ReadItem(const QString &key, QByteArray *value,
             if( !SecKeychainItemCopyContent( theItem, NULL, &attrList, &len, NULL ) ){
                 if( attr.length > 0 ){
                     osxKeyChain->lastReadService.clear();
-                    osxKeyChain->lastReadService = QString::fromUtf8( (char*)attr.data, attr.length );
+//                     osxKeyChain->lastReadService = QString::fromUtf8( (char*)attr.data, attr.length );
+                    osxKeyChain->lastReadService = folderFromService(attr);
                 }
                 SecKeychainItemFreeContent( &attrList, NULL );
             }
@@ -533,7 +657,7 @@ OSStatus OSXKeychain::WriteItem( const QString &key, const QByteArray &value,
         const QByteArray serviceName( osxKeyChain->currentService.toUtf8() );
         // save the "GenericPassword" item using the service name, which appears to be the only way to write
         // to the "Where" field shown in the Keychain Utility.
-        err = basicWriteItem( &serviceName, accountName, value, keychain, &theItem );
+        err = basicWriteItem( &osxKeyChain->currentService, accountName, value, keychain, &theItem );
         // the service (folder!) string will also appear on the "Name" field, which however can be changed
         // independently, via the Label attribute.
         saveLabel = true;
@@ -651,7 +775,8 @@ OSStatus OSXKeychain::ItemList( SecKeychainRef keychain, QStringList &keyList, O
                             // try to fetch the item's ServiceItem attribute
                             attr.tag = kSecServiceItemAttr;
                             if( !SecKeychainItemCopyContent( item, NULL, &attrList, &len, NULL ) ){
-                                QString lbl = QString::fromUtf8( (char*)attr.data, attr.length );
+//                                 QString lbl = QString::fromUtf8( (char*)attr.data, attr.length );
+                                QString lbl = folderFromService(attr);
                                 // we got a service item attribute, which is where we store the kwallet folder info.
                                 // If we disallow empty attributes, keychain items without service item attribute will
                                 // appear in each folder that has a non-empty name. In other words, we allow a folder without name.
