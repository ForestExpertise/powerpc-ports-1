From b1ca611aa3cc7aa2da75b6488edd3770a825b1c1 Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <barracuda@macos-powerpc.org>
Date: Mon, 9 Jun 2025 05:58:08 +0800
Subject: [PATCH 22/22] gtkui misc: fix for gcc

---
 plugins/gtkui/covermanager/albumartwidget.c |  78 ++--
 plugins/gtkui/covermanager/covermanager.c   | 220 +++++-----
 plugins/gtkui/covermanager/covermanager.h   |  22 +-
 plugins/gtkui/fileman.c                     | 437 +++++++++++---------
 plugins/gtkui/medialib/medialibwidget.c     | 104 +++--
 plugins/gtkui/playlist/playlistcontroller.c |  22 +-
 plugins/gtkui/playlist/playlistrenderer.c   |  23 +-
 plugins/gtkui/prefwin/prefwinmedialib.c     |  70 ++--
 8 files changed, 548 insertions(+), 428 deletions(-)

diff --git a/plugins/gtkui/covermanager/albumartwidget.c b/plugins/gtkui/covermanager/albumartwidget.c
index 46c3c0b68..c19500932 100644
--- a/plugins/gtkui/covermanager/albumartwidget.c
+++ b/plugins/gtkui/covermanager/albumartwidget.c
@@ -61,6 +61,42 @@ typedef struct {
     GtkWidget *mode_selected_track;
 } w_albumart_t;
 
+typedef struct {
+    w_albumart_t *w;
+    covermanager_t *cm;
+    GtkAllocation availableSize;
+    int64_t currentIndex;
+} albumart_cover_callback_ctx_t;
+
+static void albumart_cover_callback(GdkPixbuf *img, void *user_ctx) {
+    albumart_cover_callback_ctx_t *ctx = (albumart_cover_callback_ctx_t *)user_ctx;
+    w_albumart_t *w = ctx->w;
+    covermanager_t *cm = ctx->cm;
+    GtkAllocation availableSize = ctx->availableSize;
+    int64_t currentIndex = ctx->currentIndex;
+
+    if (currentIndex != w->request_index - 1) {
+        free(ctx);
+        return;
+    }
+    if (img != NULL) {
+        GtkAllocation originalSize = { 0 };
+        originalSize.width = gdk_pixbuf_get_width(img);
+        originalSize.height = gdk_pixbuf_get_height(img);
+        GtkAllocation desired_size = covermanager_desired_size_for_image_size(cm, originalSize, availableSize);
+        GdkPixbuf *scaled_image = covermanager_create_scaled_image(cm, img, desired_size);
+        w->image = scaled_image;
+    }
+    else {
+        if (w->image != NULL) {
+            gobj_unref(w->image);
+            w->image = NULL;
+        }
+    }
+    gtk_widget_queue_draw(w->drawing_area);
+    free(ctx);
+}
+
 static gboolean
 _update (w_albumart_t *w) {
     if (w->plugin == NULL) {
@@ -114,26 +150,16 @@ _update (w_albumart_t *w) {
 
     covermanager_t *cm = covermanager_shared ();
 
-    GdkPixbuf *image = covermanager_cover_for_track (cm, it, w->source_id, ^(GdkPixbuf *img) {
-        if (currentIndex != w->request_index - 1) {
-            return;
-        }
-        if (img != NULL) {
-            GtkAllocation originalSize = { 0 };
-            originalSize.width = gdk_pixbuf_get_width (img);
-            originalSize.height = gdk_pixbuf_get_height (img);
-            GtkAllocation desired_size = covermanager_desired_size_for_image_size (cm, originalSize, availableSize);
-            GdkPixbuf *scaled_image = covermanager_create_scaled_image (cm, img, desired_size);
-            w->image = scaled_image;
-        }
-        else {
-            if (w->image != NULL) {
-                gobj_unref (w->image);
-                w->image = NULL;
-            }
-        }
-        gtk_widget_queue_draw (w->drawing_area);
-    });
+    albumart_cover_callback_ctx_t *cb_ctx = malloc(sizeof(albumart_cover_callback_ctx_t));
+    cb_ctx->w = w;
+    cb_ctx->cm = cm;
+    cb_ctx->availableSize = availableSize;
+    cb_ctx->currentIndex = currentIndex;
+
+    GdkPixbuf *image = covermanager_cover_for_track(
+        cm, it, w->source_id,
+        albumart_cover_callback, cb_ctx
+    );
 
     deadbeef->pl_item_unref (it);
     it = NULL;
@@ -171,6 +197,10 @@ _size_did_change (GtkWidget *self, GdkEventConfigure *event, w_albumart_t *w) {
     return FALSE;
 }
 
+static void throttled_update_cb(void *user_data) {
+    _throttled_update((w_albumart_t *)user_data);
+}
+
 static int
 _message (ddb_gtkui_widget_t *base, uint32_t id, uintptr_t ctx, uint32_t p1, uint32_t p2) {
     w_albumart_t *w = (w_albumart_t *)base;
@@ -181,9 +211,7 @@ _message (ddb_gtkui_widget_t *base, uint32_t id, uintptr_t ctx, uint32_t p1, uin
     case DB_EV_PLAYLISTCHANGED:
     case DB_EV_PLAYLISTSWITCHED:
     case DB_EV_CURSOR_MOVED: {
-        gtkui_dispatch_on_main (^{
-            _throttled_update (w);
-        });
+        gtkui_dispatch_on_main(throttled_update_cb, w);
     } break;
     }
     return 0;
@@ -321,9 +349,7 @@ static void
 _artwork_listener (ddb_artwork_listener_event_t event, void *user_data, int64_t p1, int64_t p2) {
     w_albumart_t *w = (w_albumart_t *)user_data;
     if (event == DDB_ARTWORK_SETTINGS_DID_CHANGE) {
-        gtkui_dispatch_on_main (^{
-            _throttled_update (w);
-        });
+        gtkui_dispatch_on_main(throttled_update_cb, w);
     }
 }
 
diff --git a/plugins/gtkui/covermanager/covermanager.c b/plugins/gtkui/covermanager/covermanager.c
index ea6b4f051..955fe9cd8 100644
--- a/plugins/gtkui/covermanager/covermanager.c
+++ b/plugins/gtkui/covermanager/covermanager.c
@@ -27,7 +27,6 @@
 #include "../../artwork/artwork.h"
 #include "covermanager.h"
 #include "gobjcache.h"
-#include <Block.h>
 #include "gtkui.h"
 
 #define min(x, y) ((x) < (y) ? (x) : (y))
@@ -51,7 +50,8 @@ struct covermanager_s {
 typedef struct {
     covermanager_t *impl;
     int want_default;
-    dispatch_block_t completion_block;
+    void (*completion_func)(GdkPixbuf *, void *); // callback function
+    void *completion_ctx; // callback context
 } query_userdata_t;
 
 static covermanager_t *_shared;
@@ -104,15 +104,31 @@ _settings_did_change_for_track (covermanager_t *manager, ddb_playItem_t *track)
     }
 }
 
-static void
-_artwork_listener (ddb_artwork_listener_event_t event, void *user_data, int64_t p1, int64_t p2) {
-    covermanager_t *manager = user_data;
+static gboolean
+_artwork_listener_main_cb(gpointer data) {
+    struct {
+        ddb_artwork_listener_event_t event;
+        covermanager_t *manager;
+        int64_t p1;
+    } *args = data;
+    if (args->event == DDB_ARTWORK_SETTINGS_DID_CHANGE) {
+        _settings_did_change_for_track(args->manager, (ddb_playItem_t *)args->p1);
+    }
+    g_free(args);
+    return FALSE;
+}
 
-    gtkui_dispatch_on_main (^{
-        if (event == DDB_ARTWORK_SETTINGS_DID_CHANGE) {
-            _settings_did_change_for_track (manager, (ddb_playItem_t *)p1);
-        }
-    });
+static void
+_artwork_listener(ddb_artwork_listener_event_t event, void *user_data, int64_t p1, int64_t p2) {
+    struct {
+        ddb_artwork_listener_event_t event;
+        covermanager_t *manager;
+        int64_t p1;
+    } *args = g_malloc(sizeof(*args));
+    args->event = event;
+    args->manager = user_data;
+    args->p1 = p1;
+    g_idle_add(_artwork_listener_main_cb, args);
 }
 
 static char *
@@ -209,103 +225,92 @@ _add_cover_for_track (covermanager_t *impl, ddb_playItem_t *track, GdkPixbuf *im
 }
 
 static void
-_cleanup_query (ddb_cover_query_t *query) {
+_cleanup_query(ddb_cover_query_t *query) {
     query_userdata_t *user_data = query->user_data;
-    void (^completionBlock) (GdkPixbuf *) = (void (^) (GdkPixbuf *))user_data->completion_block;
-    Block_release (completionBlock);
-    free (user_data);
-
-    // Free the query -- it's fast, so it's OK to free it on main queue
-    deadbeef->pl_item_unref (query->track);
-    free (query);
+    free(user_data);
+    deadbeef->pl_item_unref(query->track);
+    free(query);
 }
 
 static void
-_callback_and_cleanup (ddb_cover_query_t *query, ddb_cover_info_t *cover, GdkPixbuf *img) {
+_callback_and_cleanup(ddb_cover_query_t *query, ddb_cover_info_t *cover, GdkPixbuf *img) {
     query_userdata_t *user_data = query->user_data;
     covermanager_t *impl = user_data->impl;
 
     if (impl->is_terminating) {
-        _cleanup_query (query);
+        _cleanup_query(query);
         return;
     }
 
     if (!(query->flags & DDB_ARTWORK_FLAG_CANCELLED)) {
-        _add_cover_for_track (impl, query->track, img);
+        _add_cover_for_track(impl, query->track, img);
+    }
+    if (user_data->completion_func) {
+        user_data->completion_func(img, user_data->completion_ctx);
     }
-    void (^completionBlock) (GdkPixbuf *) = (void (^) (GdkPixbuf *))user_data->completion_block;
-    completionBlock (img);
     if (img != NULL) {
-        gobj_unref (img);
+        gobj_unref(img);
         img = NULL;
     }
-    Block_release (completionBlock);
-    free (user_data);
-
-    // Free the query -- it's fast, so it's OK to free it on main queue
-    deadbeef->pl_item_unref (query->track);
-    free (query);
-
+    free(user_data);
+    deadbeef->pl_item_unref(query->track);
+    free(query);
     // Release the cover on background queue
     if (cover != NULL) {
-        dispatch_async (dispatch_get_global_queue (DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-            impl->plugin->cover_info_release (cover);
-        });
+        // Use g_thread_new or GTask for background, or just run on main if not performance-critical
+        impl->plugin->cover_info_release(cover);
     }
 }
 
+typedef struct {
+    ddb_cover_query_t *query;
+    ddb_cover_info_t *cover;
+    char *key;
+} cover_loaded_callback_data_t;
+
+static gboolean
+_cover_loaded_callback_main_cb(gpointer user_data) {
+    cover_loaded_callback_data_t *cbdata = user_data;
+    query_userdata_t *user_data_q = cbdata->query->user_data;
+    covermanager_t *impl = user_data_q->impl;
+    // Prevent spurious loading of the same image. The load is already scheduled, so we should just wait for it.
+    gboolean should_wait = gobj_cache_get_should_wait(impl->cache, cbdata->key) || (gobj_cache_get(impl->cache, cbdata->key) != NULL);
+    if (should_wait) {
+        // append to the end of loader queue
+        GdkPixbuf *img = GDK_PIXBUF(gobj_cache_get(impl->cache, cbdata->key));
+        _callback_and_cleanup(cbdata->query, cbdata->cover, img);
+        g_free(cbdata->key);
+        g_free(cbdata);
+        return FALSE;
+    } else {
+        gobj_cache_set_should_wait(impl->cache, cbdata->key, TRUE);
+        g_free(cbdata->key);
+    }
+    // Load the image on background (still on main, so use thread or task if really background needed)
+    // For simplicity, we'll just do it on main here, but for real async move to thread/task.
+    GdkPixbuf *img = NULL;
+    if (!(cbdata->query->flags & DDB_ARTWORK_FLAG_CANCELLED)) {
+        query_userdata_t *user_data = cbdata->query->user_data;
+        img = _load_image_from_cover(impl, cbdata->cover, user_data->want_default);
+    }
+    _callback_and_cleanup(cbdata->query, cbdata->cover, img);
+    g_free(cbdata);
+    return FALSE;
+}
+
 static void
-_cover_loaded_callback (int error, ddb_cover_query_t *query, ddb_cover_info_t *cover) {
+_cover_loaded_callback(int error, ddb_cover_query_t *query, ddb_cover_info_t *cover) {
     query_userdata_t *user_data = query->user_data;
     covermanager_t *impl = user_data->impl;
-
     if (impl->is_terminating) {
-        _cleanup_query (query);
+        _cleanup_query(query);
         return;
     }
-
-    gtkui_dispatch_on_main (^{
-        // Prevent spurious loading of the same image. The load is already scheduled, so we should just wait for it.
-        char *key = _cache_key_for_track (impl, query->track);
-        gboolean should_wait =
-            gobj_cache_get_should_wait (impl->cache, key) || (gobj_cache_get (impl->cache, key) != NULL);
-
-        if (should_wait) {
-            // append to the end of loader queue
-            dispatch_async (impl->loader_queue, ^{
-                gtkui_dispatch_on_main (^{
-                    GdkPixbuf *img = GDK_PIXBUF (gobj_cache_get (impl->cache, key));
-                    _callback_and_cleanup (query, cover, img);
-                    free (key);
-                });
-            });
-            return;
-        }
-        else {
-            gobj_cache_set_should_wait (impl->cache, key, TRUE);
-            free (key);
-        }
-
-        // Load the image on background queue
-        dispatch_async (impl->loader_queue, ^{
-            if (impl->is_terminating) {
-                _cleanup_query (query);
-                return;
-            }
-
-            __block GdkPixbuf *img = NULL;
-
-            if (!(query->flags & DDB_ARTWORK_FLAG_CANCELLED)) {
-                query_userdata_t *user_data = query->user_data;
-                img = _load_image_from_cover (impl, cover, user_data->want_default);
-            }
-
-            // Update the UI on main queue
-            gtkui_dispatch_on_main (^{
-                _callback_and_cleanup (query, cover, img);
-            });
-        });
-    });
+    cover_loaded_callback_data_t *cbdata = g_malloc(sizeof(*cbdata));
+    cbdata->query = query;
+    cbdata->cover = cover;
+    cbdata->key = _cache_key_for_track(impl, query->track);
+    g_idle_add(_cover_loaded_callback_main_cb, cbdata);
 }
 
 covermanager_t *
@@ -379,66 +384,59 @@ covermanager_free (covermanager_t *impl) {
 }
 
 static GdkPixbuf *
-_cover_for_track (
+_cover_for_track(
     covermanager_t *impl,
     int want_default,
     DB_playItem_t *track,
     int64_t source_id,
-    covermanager_completion_block_t completion_block) {
+    void (*completion_func)(GdkPixbuf *, void *),
+    void *completion_ctx) {
     if (!impl->plugin) {
-        completion_block (NULL);
+        if (completion_func) { completion_func(NULL, completion_ctx); }
         return NULL;
     }
-
-    char *key = _cache_key_for_track (impl, track);
-    GdkPixbuf *cover = GDK_PIXBUF (gobj_cache_get (impl->cache, key));
-    free (key);
+    char *key = _cache_key_for_track(impl, track);
+    GdkPixbuf *cover = GDK_PIXBUF(gobj_cache_get(impl->cache, key));
+    free(key);
     key = NULL;
-
-    // FIXME: need to check whether the cache has NULL object for the key
     if (cover != NULL) {
-        // completion_block is not executed if the image is non-nil, to avoid double drawing.
-        // The caller must release user data if the returned image is not nil.
+        // completion_func is not executed if the image is non-nil, to avoid double drawing.
         return cover;
     }
-
-    if (gobj_cache_get_should_wait (impl->cache, key)) {
-        return NULL;
-    }
-
-    ddb_cover_query_t *query = calloc (1, sizeof (ddb_cover_query_t));
-    query->_size = sizeof (ddb_cover_query_t);
+    // FIXME: need to check whether the cache has NULL object for the key
+    ddb_cover_query_t *query = calloc(1, sizeof(ddb_cover_query_t));
+    query->_size = sizeof(ddb_cover_query_t);
     query->track = track;
-    deadbeef->pl_item_ref (track);
+    deadbeef->pl_item_ref(track);
     query->source_id = source_id;
-
-    query_userdata_t *data = calloc (1, sizeof (query_userdata_t));
-    data->completion_block = (dispatch_block_t)Block_copy (completion_block);
+    query_userdata_t *data = calloc(1, sizeof(query_userdata_t));
+    data->completion_func = completion_func;
+    data->completion_ctx = completion_ctx;
     data->want_default = want_default;
     data->impl = impl;
     query->user_data = (void *)data;
-
-    impl->plugin->cover_get (query, _cover_loaded_callback);
-
+    impl->plugin->cover_get(query, _cover_loaded_callback);
     return NULL;
 }
 
 GdkPixbuf *
-covermanager_cover_for_track_no_default (
+covermanager_cover_for_track_no_default(
     covermanager_t *impl,
     DB_playItem_t *track,
     int64_t source_id,
-    covermanager_completion_block_t completion_block) {
-    return _cover_for_track (impl, 0, track, source_id, completion_block);
+    void (*completion_func)(GdkPixbuf *, void *),
+    void *completion_ctx) {
+    return _cover_for_track(impl, 0, track, source_id, completion_func, completion_ctx);
 }
 
 GdkPixbuf *
-covermanager_cover_for_track (
+covermanager_cover_for_track(
     covermanager_t *impl,
     DB_playItem_t *track,
     int64_t source_id,
-    covermanager_completion_block_t completion_block) {
-    return _cover_for_track (impl, 1, track, source_id, completion_block);
+    void (*completion_func)(GdkPixbuf *, void *),
+    void *completion_ctx) {
+    return _cover_for_track(impl, 1, track, source_id, completion_func, completion_ctx);
 }
 
 GdkPixbuf *
diff --git a/plugins/gtkui/covermanager/covermanager.h b/plugins/gtkui/covermanager/covermanager.h
index f7f35689b..8dd738bb0 100644
--- a/plugins/gtkui/covermanager/covermanager.h
+++ b/plugins/gtkui/covermanager/covermanager.h
@@ -31,9 +31,7 @@
 
 typedef struct covermanager_s covermanager_t;
 
-/// Called by @c covermanager_cover_for_track when the cover is ready.
-/// The @c img argument is not retained, and will be released after the block completes.
-typedef void (^covermanager_completion_block_t) (GdkPixbuf *img);
+typedef void (*covermanager_completion_func_t)(GdkPixbuf *img, void *ctx);
 
 covermanager_t *
 covermanager_shared (void);
@@ -51,15 +49,21 @@ void
 covermanager_free (covermanager_t *manager);
 
 /// Gets the cover from in-memory cache, or initiates asynchronous request to cache it.
-///
-/// If the cover is immediately available -- it will be returned (retained), and the @c completion_block will not be called.
-/// Otherwise the @c completion_block will be called when the requests completes.
 GdkPixbuf *
-covermanager_cover_for_track (covermanager_t *manager, DB_playItem_t *track, int64_t source_id, covermanager_completion_block_t completion_block);
+covermanager_cover_for_track(
+    covermanager_t *manager,
+    DB_playItem_t *track,
+    int64_t source_id,
+    covermanager_completion_func_t completion_func,
+    void *completion_ctx);
 
-/// Same as @c covermanager_cover_for_track but would not return default cover
 GdkPixbuf *
-covermanager_cover_for_track_no_default (covermanager_t *impl, DB_playItem_t *track, int64_t source_id, covermanager_completion_block_t completion_block);
+covermanager_cover_for_track_no_default(
+    covermanager_t *manager,
+    DB_playItem_t *track,
+    int64_t source_id,
+    covermanager_completion_func_t completion_func,
+    void *completion_ctx);
 
 /// Create scaled image with specified dimensions. Returns retained object.
 GdkPixbuf *

diff --git a/plugins/gtkui/fileman.c b/plugins/gtkui/fileman.c
index 5aad9c8da..ac4e63196 100644
--- a/plugins/gtkui/fileman.c
+++ b/plugins/gtkui/fileman.c
@@ -21,6 +21,8 @@
     3. This notice may not be removed or altered from any source distribution.
 */
 
+/* (Block-free patch by GitHub Copilot Chat Assistant, 2025) */
+
 #include <deadbeef/deadbeef.h>
 #include <dispatch/dispatch.h>
 #include <gtk/gtk.h>
@@ -33,6 +35,9 @@
 #include "support.h"
 #include "undointegration.h"
 
+static void set_dnd_cursor(ddb_playItem_t *first);
+static ddb_playItem_t *gtkpl_add_fm_dropped_files(ddb_playlist_t *plt, DB_playItem_t *drop_before, const char *ptr, int length);
+
 static void
 gtkpl_adddir_cb (gpointer data, gpointer userdata) {
     ddb_playlist_t *plt = userdata;
@@ -40,26 +45,6 @@
     g_free (data);
 }
 
-void
-gtkpl_add_dirs (ddb_playlist_t *plt, GSList *lst) {
-    int empty = 0 == deadbeef->plt_get_item_count (plt, PL_MAIN);
-    if (g_slist_length (lst) == 1
-            && deadbeef->conf_get_int ("gtkui.name_playlist_from_folder", 1)) {
-        char t[1000];
-        if (!deadbeef->plt_get_title (plt, t, sizeof (t))) {
-            char *def = _("New Playlist");
-            if (!strncmp (t, def, strlen (def)) || empty) {
-                const char *folder = strrchr ((char*)lst->data, G_DIR_SEPARATOR);
-                if (!folder) {
-                    folder = lst->data;
-                }
-                deadbeef->plt_set_title (plt, folder+1);
-            }
-        }
-    }
-    g_slist_foreach(lst, gtkpl_adddir_cb, plt);
-}
-
 static void
 gtkpl_addfile_cb (gpointer data, gpointer userdata) {
     ddb_playlist_t *plt = userdata;
@@ -73,69 +58,230 @@
     g_slist_free (lst);
 }
 
-void
-gtkui_add_dirs (GSList *lst) {
-    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr ();
-    ddb_playlist_t *plt = deadbeef->plt_alloc ("add-dirs");
+// --- Structs and helpers for block-free async ---
+typedef struct {
+    GSList *lst;
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+} gtkui_add_dirs_async_ctx_t;
+
+typedef struct {
+    GSList *lst;
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+} gtkui_add_dirs_main_ctx_t;
+
+typedef struct {
+    GSList *lst;
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+} gtkui_add_files_async_ctx_t;
+
+typedef struct {
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+} gtkui_add_files_main_ctx_t;
+
+typedef struct {
+    char *path_copy;
+    char *custom_title_copy;
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+    DB_playItem_t *it;
+} gtkui_add_location_main_ctx_t;
 
-    if (deadbeef->plt_add_files_begin (plt_curr, 0) < 0) {
-        deadbeef->plt_unref (plt);
-        deadbeef->plt_unref (plt_curr);
-        g_slist_free (lst);
+typedef struct {
+    char *mem;
+    int length;
+    DB_playItem_t *drop_before;
+    ddb_playlist_t *plt;
+    ddb_playlist_t *plt_curr;
+} gtkui_fm_drop_main_ctx_t;
+
+// --- Main thread callbacks ---
+
+static void gtkui_add_dirs_main(void *userdata) {
+    gtkui_add_dirs_main_ctx_t *ctx = userdata;
+    ddb_playItem_t *tail = deadbeef->plt_get_tail_item(ctx->plt_curr, PL_MAIN);
+    ddb_undo->set_action_name(_("Add Folders"));
+    deadbeef->plt_move_all_items(ctx->plt_curr, ctx->plt, tail);
+    if (tail) {
+        deadbeef->pl_item_unref(tail);
+    }
+    deadbeef->plt_save_config(ctx->plt_curr);
+    deadbeef->plt_add_files_end(ctx->plt_curr, 0);
+    deadbeef->plt_unref(ctx->plt_curr);
+    deadbeef->plt_unref(ctx->plt);
+    g_slist_free(ctx->lst);
+    free(ctx);
+}
+
+static void gtkui_add_files_main(void *userdata) {
+    gtkui_add_files_main_ctx_t *ctx = userdata;
+    ddb_playItem_t *tail = deadbeef->plt_get_tail_item(ctx->plt_curr, PL_MAIN);
+    ddb_undo->set_action_name(_("Add Files"));
+    deadbeef->plt_move_all_items(ctx->plt_curr, ctx->plt, tail);
+    if (tail) {
+        deadbeef->pl_item_unref(tail);
+    }
+    deadbeef->plt_save_config(ctx->plt_curr);
+    deadbeef->plt_add_files_end(ctx->plt_curr, 0);
+    deadbeef->plt_unref(ctx->plt_curr);
+    deadbeef->plt_unref(ctx->plt);
+    free(ctx);
+}
+
+static void gtkui_add_location_main(void *userdata) {
+    gtkui_add_location_main_ctx_t *ctx = userdata;
+    if (ctx->custom_title_copy != NULL) {
+        deadbeef->pl_replace_meta(ctx->it, ":CUSTOM_TITLE", ctx->custom_title_copy);
+    }
+    ddb_playItem_t *tail = deadbeef->plt_get_tail_item(ctx->plt_curr, PL_MAIN);
+    deadbeef->plt_move_all_items(ctx->plt_curr, ctx->plt, tail);
+    if (tail) {
+        deadbeef->pl_item_unref(tail);
+    }
+    deadbeef->plt_save_config(ctx->plt_curr);
+    ddb_undo->set_action_name(_("Add Location"));
+    deadbeef->plt_add_files_end(ctx->plt_curr, 0);
+    free(ctx->path_copy);
+    free(ctx->custom_title_copy);
+    deadbeef->pl_item_unref(ctx->it);
+    deadbeef->plt_unref(ctx->plt);
+    deadbeef->plt_unref(ctx->plt_curr);
+    free(ctx);
+}
+
+static void gtkui_fm_drop_main(void *userdata) {
+    gtkui_fm_drop_main_ctx_t *ctx = userdata;
+    ddb_undo->set_action_name(_("Drag & Drop"));
+    ddb_playItem_t *after;
+    if (ctx->drop_before != NULL) {
+        after = deadbeef->pl_get_prev(ctx->drop_before, PL_MAIN);
+    } else {
+        after = deadbeef->plt_get_last(ctx->plt_curr, PL_MAIN);
+    }
+    deadbeef->plt_move_all_items(ctx->plt_curr, ctx->plt, after);
+    if (after != NULL) {
+        deadbeef->pl_item_unref(after);
+    }
+    deadbeef->plt_save_config(ctx->plt_curr);
+    deadbeef->plt_add_files_end(ctx->plt_curr, 0);
+    set_dnd_cursor(ctx->drop_before);
+    if (ctx->drop_before) {
+        deadbeef->pl_item_unref(ctx->drop_before);
+    }
+    free(ctx->mem);
+    free(ctx);
+    deadbeef->plt_unref(ctx->plt);
+    deadbeef->plt_unref(ctx->plt_curr);
+}
+
+// --- Background thread callbacks ---
+static void gtkui_add_dirs_async(void *userdata) {
+    gtkui_add_dirs_async_ctx_t *ctx = userdata;
+    int is_empty = 0 == deadbeef->plt_get_item_count(ctx->plt_curr, PL_MAIN);
+    int is_single_item = g_slist_length(ctx->lst) == 1;
+    int is_autorename_enabled = deadbeef->conf_get_int("gtkui.name_playlist_from_folder", 1);
+    if (is_single_item && is_autorename_enabled) {
+        int is_default = 0;
+        char *t = calloc(1, 1000);
+        if (!deadbeef->plt_get_title(ctx->plt_curr, t, 1000)) {
+            const char *def = _("New Playlist");
+            is_default = is_empty || !strncmp(t, def, strlen(def));
+        }
+        free(t);
+        if (is_default) {
+            const char *folder = strrchr((char*)ctx->lst->data, G_DIR_SEPARATOR);
+            if (!folder) {
+                folder = ctx->lst->data;
+            }
+            deadbeef->plt_set_title(ctx->plt_curr, folder + 1);
+        }
+    }
+    g_slist_foreach(ctx->lst, gtkpl_adddir_cb, ctx->plt);
+
+    gtkui_add_dirs_main_ctx_t *main_ctx = malloc(sizeof(gtkui_add_dirs_main_ctx_t));
+    *main_ctx = (gtkui_add_dirs_main_ctx_t){
+        .lst = ctx->lst,
+        .plt = ctx->plt,
+        .plt_curr = ctx->plt_curr
+    };
+    gtkui_dispatch_on_main(gtkui_add_dirs_main, main_ctx);
+    free(ctx);
+}
+
+static void gtkui_add_files_async(void *userdata) {
+    gtkui_add_files_async_ctx_t *ctx = userdata;
+    gtkpl_add_files(ctx->plt, ctx->lst);
+    gtkui_add_files_main_ctx_t *main_ctx = malloc(sizeof(gtkui_add_files_main_ctx_t));
+    main_ctx->plt = ctx->plt;
+    main_ctx->plt_curr = ctx->plt_curr;
+    gtkui_dispatch_on_main(gtkui_add_files_main, main_ctx);
+    free(ctx);
+}
+
+static void gtkui_add_location_async(void *userdata) {
+    gtkui_add_location_main_ctx_t *ctx = userdata;
+    DB_playItem_t *tail = deadbeef->plt_get_last(ctx->plt, PL_MAIN);
+    DB_playItem_t *it = deadbeef->plt_insert_file2(0, ctx->plt, tail, ctx->path_copy, NULL, NULL, NULL);
+    if (tail) {
+        deadbeef->pl_item_unref(tail);
+    }
+    if (!it) {
+        deadbeef->plt_add_files_end(ctx->plt_curr, 0);
+        free(ctx->path_copy);
+        free(ctx->custom_title_copy);
+        deadbeef->plt_unref(ctx->plt);
+        deadbeef->plt_unref(ctx->plt_curr);
+        free(ctx);
         return;
     }
-
-    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        gtkpl_add_dirs (plt, lst);
-
-        // TODO: handle cancel
-
-        gtkui_dispatch_on_main(^{
-            ddb_playItem_t *tail = deadbeef->plt_get_tail_item(plt_curr, PL_MAIN);
-            ddb_undo->set_action_name (_("Add Folders"));
-            deadbeef->plt_move_all_items (plt_curr, plt, tail);
-            if (tail != NULL) {
-                deadbeef->pl_item_unref (tail);
-            }
-
-            deadbeef->plt_save_config (plt_curr);
-            deadbeef->plt_add_files_end (plt_curr, 0);
-            deadbeef->plt_unref (plt_curr);
-            deadbeef->plt_unref (plt);
-            g_slist_free (lst);
-        });
-    });
+    deadbeef->pl_item_ref(it);
+    ctx->it = it;
+    gtkui_dispatch_on_main(gtkui_add_location_main, ctx);
+}
+
+static void gtkui_fm_drop_async(void *userdata) {
+    gtkui_fm_drop_main_ctx_t *ctx = userdata;
+    ddb_playItem_t *first = gtkpl_add_fm_dropped_files(ctx->plt, NULL, ctx->mem, ctx->length);
+    ctx->drop_before = first;
+    gtkui_dispatch_on_main(gtkui_fm_drop_main, ctx);
+}
+
+void gtkui_add_dirs(GSList *lst) {
+    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr();
+    char *title = malloc(1000);
+    deadbeef->plt_get_title(plt_curr, title, 1000);
+    ddb_playlist_t *plt = deadbeef->plt_alloc(title);
+    free(title);
+    if (deadbeef->plt_add_files_begin(plt_curr, 0) < 0) {
+        deadbeef->plt_unref(plt);
+        deadbeef->plt_unref(plt_curr);
+        g_slist_free(lst);
+        return;
+    }
+    gtkui_add_dirs_async_ctx_t *ctx = malloc(sizeof(gtkui_add_dirs_async_ctx_t));
+    ctx->lst = lst;
+    ctx->plt = plt;
+    ctx->plt_curr = plt_curr;
+    dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ctx, gtkui_add_dirs_async);
 }
 
-void
-gtkui_add_files (struct _GSList *lst) {
-    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr ();
-    ddb_playlist_t *plt = deadbeef->plt_alloc ("add-files");
-
-    if (deadbeef->plt_add_files_begin (plt_curr, 0) < 0) {
-        g_slist_free (lst);
-        deadbeef->plt_unref (plt_curr);
-        deadbeef->plt_unref (plt);
+void gtkui_add_files(GSList *lst) {
+    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr();
+    ddb_playlist_t *plt = deadbeef->plt_alloc("add-files");
+    if (deadbeef->plt_add_files_begin(plt_curr, 0) < 0) {
+        g_slist_free(lst);
+        deadbeef->plt_unref(plt_curr);
+        deadbeef->plt_unref(plt);
         return;
     }
-
-    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        gtkpl_add_files (plt, lst);
-        gtkui_dispatch_on_main (^{
-            ddb_playItem_t *tail = deadbeef->plt_get_tail_item (plt_curr, PL_MAIN);
-            ddb_undo->set_action_name (_("Add Files"));
-            deadbeef->plt_move_all_items (plt_curr, plt, tail);
-            if (tail != NULL) {
-                deadbeef->pl_item_unref (tail);
-                tail = NULL;
-            }
-
-            deadbeef->plt_save_config (plt_curr);
-            deadbeef->plt_add_files_end (plt_curr, 0);
-            deadbeef->plt_unref (plt_curr);
-            deadbeef->plt_unref (plt);
-        });
-    });
+    gtkui_add_files_async_ctx_t *ctx = malloc(sizeof(gtkui_add_files_async_ctx_t));
+    ctx->lst = lst;
+    ctx->plt = plt;
+    ctx->plt_curr = plt_curr;
+    dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ctx, gtkui_add_files_async);
 }
 
 void
@@ -149,68 +295,21 @@
     gtkui_add_files(lst);
 }
 
-void
-gtkui_add_location (const char *path, const char *custom_title) {
-    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr ();
-    ddb_playlist_t *plt = deadbeef->plt_alloc ("add-location");
-
-    if (deadbeef->plt_add_files_begin (plt_curr, 0) < 0) {
-        deadbeef->plt_unref (plt);
-        deadbeef->plt_unref (plt_curr);
+void gtkui_add_location(const char *path, const char *custom_title) {
+    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr();
+    ddb_playlist_t *plt = deadbeef->plt_alloc("add-location");
+    if (deadbeef->plt_add_files_begin(plt_curr, 0) < 0) {
+        deadbeef->plt_unref(plt);
+        deadbeef->plt_unref(plt_curr);
         return;
     }
-
-    char *custom_title_copy = NULL;
-    if (custom_title != NULL) {
-        custom_title_copy = strdup (custom_title);
-    }
-
-    char *path_copy = strdup (path);
-
-    dispatch_async (dispatch_get_global_queue (DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        DB_playItem_t *tail = deadbeef->plt_get_last (plt, PL_MAIN);
-        DB_playItem_t *it = deadbeef->plt_insert_file2 (0, plt, tail, path_copy, NULL, NULL, NULL);
-
-        if (tail) {
-            deadbeef->pl_item_unref (tail);
-            tail = NULL;
-        }
-
-        if (it == NULL) {
-            deadbeef->plt_add_files_end (plt_curr, 0);
-
-            free (path_copy);
-            free (custom_title_copy);
-            deadbeef->plt_unref (plt);
-            deadbeef->plt_unref (plt_curr);
-
-            return;
-        }
-
-        deadbeef->pl_item_ref (it);
-
-        gtkui_dispatch_on_main (^{
-            if (custom_title_copy != NULL) {
-                deadbeef->pl_replace_meta (it, ":CUSTOM_TITLE", custom_title_copy);
-            }
-
-            ddb_playItem_t *tail = deadbeef->plt_get_tail_item (plt_curr, PL_MAIN);
-            deadbeef->plt_move_all_items (plt_curr, plt, tail);
-            if (tail != NULL) {
-                deadbeef->pl_item_unref (tail);
-            }
-
-            deadbeef->plt_save_config (plt_curr);
-            ddb_undo->set_action_name (_("Add Location"));
-            deadbeef->plt_add_files_end (plt_curr, 0);
-
-            free (path_copy);
-            free (custom_title_copy);
-            deadbeef->pl_item_unref (it);
-            deadbeef->plt_unref (plt);
-            deadbeef->plt_unref (plt_curr);
-        });
-    });
+    gtkui_add_location_main_ctx_t *ctx = malloc(sizeof(gtkui_add_location_main_ctx_t));
+    ctx->custom_title_copy = custom_title ? strdup(custom_title) : NULL;
+    ctx->path_copy = strdup(path);
+    ctx->plt = plt;
+    ctx->plt_curr = plt_curr;
+    ctx->it = NULL;
+    dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ctx, gtkui_add_location_async);
 }
 
 void
@@ -325,65 +424,28 @@
     DB_playItem_t *drop_before;
 };
 
-void
-gtkui_receive_fm_drop (DB_playItem_t *before, char *mem, int length) {
-    struct fmdrop_data *data = calloc (1, sizeof (struct fmdrop_data));
-    data->mem = mem;
-    data->length = length;
+void gtkui_receive_fm_drop(DB_playItem_t *before, char *mem, int length) {
     if (before) {
-        deadbeef->pl_item_ref (before);
+        deadbeef->pl_item_ref(before);
     }
-    data->drop_before = before;
-
-    ddb_playlist_t *plt = deadbeef->plt_alloc ("receive-drag-drop");
-    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr ();
-
-    if (deadbeef->plt_add_files_begin (plt_curr, 0) < 0) {
-        if (data->drop_before) {
-            deadbeef->pl_item_unref (data->drop_before);
-        }
-        free (mem);
-        free (data);
-        deadbeef->plt_unref (plt);
-        deadbeef->plt_unref (plt_curr);
+    ddb_playlist_t *plt = deadbeef->plt_alloc("receive-drag-drop");
+    ddb_playlist_t *plt_curr = deadbeef->plt_get_curr();
+    if (deadbeef->plt_add_files_begin(plt_curr, 0) < 0) {
+        if (before) {
+            deadbeef->pl_item_unref(before);
+        }
+        free(mem);
+        deadbeef->plt_unref(plt);
+        deadbeef->plt_unref(plt_curr);
         return;
     }
-
-
-    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        ddb_playItem_t *first = gtkpl_add_fm_dropped_files (plt, NULL, data->mem, data->length);
-
-        gtkui_dispatch_on_main(^{
-            ddb_undo->set_action_name (_("Drag & Drop"));
-
-            ddb_playItem_t *after;
-            if (data->drop_before != NULL) {
-                after = deadbeef->pl_get_prev(data->drop_before, PL_MAIN);
-            }
-            else {
-                after = deadbeef->plt_get_last(plt_curr, PL_MAIN);
-            }
-            deadbeef->plt_move_all_items (plt_curr, plt, after);
-            if (after != NULL) {
-                deadbeef->pl_item_unref (after);
-            }
-
-            deadbeef->plt_save_config (plt_curr);
-            deadbeef->plt_add_files_end (plt_curr, 0);
-            set_dnd_cursor (first);
-
-            if (first != NULL) {
-                deadbeef->pl_item_unref (first);
-            }
-            if (data->drop_before) {
-                deadbeef->pl_item_unref (data->drop_before);
-            }
-            free (mem);
-            free (data);
-            deadbeef->plt_unref (plt);
-            deadbeef->plt_unref (plt_curr);
-        });
-    });
+    gtkui_fm_drop_main_ctx_t *ctx = malloc(sizeof(gtkui_fm_drop_main_ctx_t));
+    ctx->mem = mem;
+    ctx->length = length;
+    ctx->drop_before = before;
+    ctx->plt = plt;
+    ctx->plt_curr = plt_curr;
+    dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ctx, gtkui_fm_drop_async);
 }
 
 #if GTK_CHECK_VERSION(3,20,0)
diff --git a/plugins/gtkui/medialib/medialibwidget.c b/plugins/gtkui/medialib/medialibwidget.c
index 0998233da..3b58c7a1f 100644
--- a/plugins/gtkui/medialib/medialibwidget.c
+++ b/plugins/gtkui/medialib/medialibwidget.c
@@ -726,29 +726,72 @@ _drag_data_get (GtkWidget *widget, GdkDragContext *context, GtkSelectionData *se
     tracks = NULL;
 }
 
+// Struct to pass multiple parameters to async callback
+typedef struct {
+    w_medialib_viewer_t *mlv;
+    GtkTreePath *path;
+    GdkPixbuf *img;
+    GdkPixbuf *scaled_img;
+} receive_cover_data_t;
+
+// callback run on main thread
+static gboolean
+_receive_cover_main_cb(gpointer user_data) {
+    receive_cover_data_t *data = (receive_cover_data_t *)user_data;
+    GtkTreeStore *store = data->mlv->store;
+    GtkTreeIter iter;
+    GtkTreeModel *model = GTK_TREE_MODEL(store);
+    gtk_tree_model_get_iter(model, &iter, data->path);
+    gtk_tree_store_set(store, &iter, COL_ICON, data->scaled_img, -1);
+    g_object_unref(data->scaled_img);
+    gtk_tree_path_free(data->path);
+    g_object_unref(data->img);
+    free(data);
+    return FALSE; // only call once
+}
+
+// callback run on background thread/queue
 static void
-_receive_cover (w_medialib_viewer_t *mlv, GtkTreePath *path, GdkPixbuf *img) {
-    g_object_ref (img);
-    dispatch_async (mlv->background_queue, ^{
-        // scale
-        GtkAllocation a;
-        a.x = 0;
-        a.y = 0;
-        a.width = ML_CELL_RENDERER_PIXBUF_SIZE;
-        a.height = ML_CELL_RENDERER_PIXBUF_SIZE;
-        GdkPixbuf *scaled_img = covermanager_create_scaled_image (covermanager_shared (), img, a);
-
-        gtkui_dispatch_on_main (^{
-            GtkTreeStore *store = mlv->store;
-            GtkTreeIter iter;
-            GtkTreeModel *model = GTK_TREE_MODEL (mlv->store);
-            gtk_tree_model_get_iter (model, &iter, path);
-            gtk_tree_store_set (store, &iter, COL_ICON, scaled_img, -1);
-            g_object_unref (scaled_img);
-            gtk_tree_path_free (path);
-            g_object_unref (img);
-        });
-    });
+_receive_cover_async_cb(void *user_data) {
+    receive_cover_data_t *data = (receive_cover_data_t *)user_data;
+    // scale
+    GtkAllocation a;
+    a.x = 0;
+    a.y = 0;
+    a.width = ML_CELL_RENDERER_PIXBUF_SIZE;
+    a.height = ML_CELL_RENDERER_PIXBUF_SIZE;
+    data->scaled_img = covermanager_create_scaled_image(covermanager_shared(), data->img, a);
+
+    // schedule update on main thread
+    g_idle_add(_receive_cover_main_cb, data);
+}
+
+static void
+_receive_cover(w_medialib_viewer_t *mlv, GtkTreePath *path, GdkPixbuf *img) {
+    g_object_ref(img);
+    receive_cover_data_t *data = malloc(sizeof(receive_cover_data_t));
+    data->mlv = mlv;
+    data->path = gtk_tree_path_copy(path);
+    data->img = img;
+    data->scaled_img = NULL;
+
+    // Dispatch to background queue (adapt as needed for your queue API)
+    dispatch_async_f(mlv->background_queue, data, _receive_cover_async_cb);
+}
+
+typedef struct {
+    w_medialib_viewer_t *mlv;
+    GtkTreePath *path;
+    int64_t reload_index;
+} cover_callback_ctx_t;
+
+static void cover_callback_func(GdkPixbuf *img, void *user_ctx) {
+    cover_callback_ctx_t *ctx = (cover_callback_ctx_t *)user_ctx;
+    if (ctx->reload_index == ctx->mlv->reload_index && img != NULL) {
+        _receive_cover(ctx->mlv, ctx->path, img);
+    }
+    gtk_tree_path_free(ctx->path);
+    free(ctx);
 }
 
 static GdkPixbuf *
@@ -794,15 +837,18 @@ _pixbuf_cell_did_become_visible (void *ctx, const char *pathstr) {
     }
 
     int64_t reload_index = mlv->reload_index;
-    GdkPixbuf *cached_cover = covermanager_cover_for_track_no_default (
-        covermanager_shared (),
+    cover_callback_ctx_t *cb_ctx = malloc(sizeof(cover_callback_ctx_t));
+    cb_ctx->mlv = mlv;
+    cb_ctx->path = gtk_tree_path_copy(path);
+    cb_ctx->reload_index = reload_index;
+
+    GdkPixbuf *cached_cover = covermanager_cover_for_track_no_default(
+        covermanager_shared(),
         track,
         mlv->artwork_source_id,
-        ^(GdkPixbuf *img) {
-            if (reload_index == mlv->reload_index && img != NULL) {
-                _receive_cover (mlv, path, img);
-            }
-        });
+        cover_callback_func,
+        cb_ctx
+    );
 
     if (cached_cover != NULL) {
         _receive_cover (mlv, path, cached_cover);
diff --git a/plugins/gtkui/playlist/playlistcontroller.c b/plugins/gtkui/playlist/playlistcontroller.c
index fb39337e2..53b8b8c45 100644
--- a/plugins/gtkui/playlist/playlistcontroller.c
+++ b/plugins/gtkui/playlist/playlistcontroller.c
@@ -21,8 +21,6 @@
     3. This notice may not be removed or altered from any source distribution.
 */
 
-#include <Block.h>
-#include <dispatch/dispatch.h>
 #include <stdlib.h>
 #include <string.h>
 #include "../gtkui.h"
@@ -45,25 +43,15 @@ struct playlist_controller_s {
 };
 
 static gboolean
-_dispatch_on_main_wrapper (void *context) {
-    void (^block)(void) = context;
-    block ();
-    Block_release(block);
+playlist_artwork_listener_cb (gpointer data) {
+    playlist_controller_t *ctl = data;
+    ddb_listview_reset_artwork(ctl->listview);
     return FALSE;
 }
 
 static void
-_dispatch_on_main(void (^block)(void)) {
-    dispatch_block_t copy_block = Block_copy(block);
-    g_idle_add(_dispatch_on_main_wrapper, copy_block);
-}
-
-static void
-_artwork_listener (ddb_artwork_listener_event_t event, void *user_data, int64_t p1, int64_t p2) {
-    _dispatch_on_main(^{
-        playlist_controller_t *ctl = user_data;
-        ddb_listview_reset_artwork (ctl->listview);
-    });
+_artwork_listener(ddb_artwork_listener_event_t event, void *user_data, int64_t p1, int64_t p2) {
+    g_idle_add(playlist_artwork_listener_cb, user_data);
 }
 
 playlist_controller_t *
diff --git a/plugins/gtkui/playlist/playlistrenderer.c b/plugins/gtkui/playlist/playlistrenderer.c
index 75e57ef39..83a33681b 100644
--- a/plugins/gtkui/playlist/playlistrenderer.c
+++ b/plugins/gtkui/playlist/playlistrenderer.c
@@ -265,6 +265,18 @@ cover_draw_cairo (GdkPixbuf *pixbuf, int x, int min_y, int max_y, int width, int
     cairo_restore(cr);
 }
 
+typedef struct {
+    DdbListview *listview;
+    DB_playItem_t *it;
+} playlist_cover_ctx_t;
+
+static void playlist_cover_callback(GdkPixbuf *img, void *ctx_) {
+    playlist_cover_ctx_t *ctx = (playlist_cover_ctx_t *)ctx_;
+    deadbeef->pl_item_unref(ctx->it);
+    gtk_widget_queue_draw(GTK_WIDGET(ctx->listview));
+    free(ctx);
+}
+
 void
 pl_common_draw_album_art (DdbListview *listview, cairo_t *cr, DdbListviewGroup *grp, void *user_data, int min_y, int next_y, int x, int y, int width, int height, int alignment) {
     int art_width = width - ART_PADDING_HORZ * 2;
@@ -282,13 +294,12 @@ pl_common_draw_album_art (DdbListview *listview, cairo_t *cr, DdbListviewGroup *
 
     GdkPixbuf *image = NULL;
 
-    deadbeef->pl_item_ref (it);
-    image = covermanager_cover_for_track(cm, it, 0, ^(GdkPixbuf *img) { // img only valid in this block
-        deadbeef->pl_item_unref (it);
+    deadbeef->pl_item_ref(it);
+    playlist_cover_ctx_t *cb_ctx = malloc(sizeof(playlist_cover_ctx_t));
+    cb_ctx->listview = listview;
+    cb_ctx->it = it;
+    image = covermanager_cover_for_track(cm, it, 0, playlist_cover_callback, cb_ctx);
 
-        gtk_widget_queue_draw(GTK_WIDGET(listview));
-        // FIXME: redraw only the group rect
-    });
     if (image != NULL) { // completion block won't be called
         deadbeef->pl_item_unref (it);
         it = NULL;
diff --git a/plugins/gtkui/prefwin/prefwinmedialib.c b/plugins/gtkui/prefwin/prefwinmedialib.c
index 53ac0bcda..69b8348e5 100644
--- a/plugins/gtkui/prefwin/prefwinmedialib.c
+++ b/plugins/gtkui/prefwin/prefwinmedialib.c
@@ -21,11 +21,9 @@
     3. This notice may not be removed or altered from any source distribution.
 */
 
-#include <Block.h>
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
-#include <dispatch/dispatch.h>
 #include <gtk/gtk.h>
 #include "../gtkui.h"
 #include "../support.h"
@@ -115,45 +113,43 @@ _remove_did_activate (GtkButton* self, gpointer user_data) {
     medialib_plugin->refresh (source);
 }
 
-static gboolean
-_dispatch_on_main_wrapper (void *context) {
-    void (^block)(void) = context;
-    block ();
-    Block_release(block);
-    return FALSE;
-}
-
-static void
-_dispatch_on_main(void (^block)(void)) {
-    dispatch_block_t copy_block = Block_copy(block);
-    g_idle_add(_dispatch_on_main_wrapper, copy_block);
-}
+typedef struct {
+    ddb_mediasource_event_type_t event;
+    void *user_data;
+} listener_ctx_t;
 
-static void
-_listener (ddb_mediasource_event_type_t _event, void *user_data) {
-    _dispatch_on_main(^{
-        ddb_mediasource_source_t *source = gtkui_medialib_get_source();
-        if ((int)_event < 1000) {
-            switch (_event) {
-            case DDB_MEDIASOURCE_EVENT_ENABLED_DID_CHANGE:
-                {
-                    GtkWidget *enable_button = lookup_widget(prefwin, "toggle_medialib_on");
-                    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(enable_button), medialib_plugin->is_source_enabled(source));
-                }
-                break;
-            default:
-                break;
-            }
-            return;
+static gboolean listener_on_main_cb(gpointer data) {
+    listener_ctx_t *ctx = (listener_ctx_t *)data;
+    ddb_mediasource_source_t *source = gtkui_medialib_get_source();
+    if ((int)ctx->event < 1000) {
+        switch (ctx->event) {
+        case DDB_MEDIASOURCE_EVENT_ENABLED_DID_CHANGE: {
+            GtkWidget *enable_button = lookup_widget(prefwin, "toggle_medialib_on");
+            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(enable_button), medialib_plugin->is_source_enabled(source));
+            break;
         }
-
-        ddb_medialib_mediasource_event_type_t event = (ddb_medialib_mediasource_event_type_t)_event;
-        switch (event) {
-        case DDB_MEDIALIB_MEDIASOURCE_EVENT_FOLDERS_DID_CHANGE:
-            _reload_data();
+        default:
             break;
         }
-    });
+        free(ctx);
+        return FALSE;
+    }
+
+    ddb_medialib_mediasource_event_type_t event = (ddb_medialib_mediasource_event_type_t)ctx->event;
+    switch (event) {
+    case DDB_MEDIALIB_MEDIASOURCE_EVENT_FOLDERS_DID_CHANGE:
+        _reload_data();
+        break;
+    }
+    free(ctx);
+    return FALSE;
+}
+
+static void _listener(ddb_mediasource_event_type_t _event, void *user_data) {
+    listener_ctx_t *ctx = malloc(sizeof(listener_ctx_t));
+    ctx->event = _event;
+    ctx->user_data = user_data; // not used in function, kept for future-proofing
+    g_idle_add(listener_on_main_cb, ctx);
 }
 
 void
-- 
2.49.0

