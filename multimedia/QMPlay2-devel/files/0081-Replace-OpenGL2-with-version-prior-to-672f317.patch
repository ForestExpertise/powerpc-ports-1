From 4ff7ef180951339d6a9237a61f4ec4c0ce59232e Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <barracuda@macos-powerpc.org>
Date: Fri, 23 May 2025 13:22:32 +0800
Subject: [PATCH 81/85] Replace OpenGL2 with version prior to 672f317

---
 src/modules/OpenGL2/CMakeLists.txt       |   71 +-
 src/modules/OpenGL2/GLSL/Bicubic.frag    |   67 -
 src/modules/OpenGL2/GLSL/VideoRGB.frag   |   19 +-
 src/modules/OpenGL2/GLSL/VideoYCbCr.frag |   39 +-
 src/modules/OpenGL2/OpenGL2.cpp          |  151 +-
 src/modules/OpenGL2/OpenGL2.hpp          |   54 +-
 src/modules/OpenGL2/OpenGL2.pro          |   35 +
 src/modules/OpenGL2/OpenGL2Common.cpp    | 1855 ++++++++++------------
 src/modules/OpenGL2/OpenGL2Common.hpp    |  223 ++-
 src/modules/OpenGL2/OpenGL2CommonQt5.cpp |   35 +
 src/modules/OpenGL2/OpenGL2CommonQt5.hpp |   27 +
 src/modules/OpenGL2/OpenGL2OldWidget.cpp |  100 ++
 src/modules/OpenGL2/OpenGL2OldWidget.hpp |   47 +
 src/modules/OpenGL2/OpenGL2Widget.cpp    |   74 +-
 src/modules/OpenGL2/OpenGL2Widget.hpp    |   48 +-
 src/modules/OpenGL2/OpenGL2Window.cpp    |  182 +--
 src/modules/OpenGL2/OpenGL2Window.hpp    |   64 +-
 src/modules/OpenGL2/OpenGL2Writer.cpp    |  376 +++--
 src/modules/OpenGL2/OpenGL2Writer.hpp    |   71 +-
 src/modules/OpenGL2/Sphere.cpp           |   80 +-
 src/modules/OpenGL2/Sphere.hpp           |   28 +-
 src/modules/OpenGL2/Vertices.hpp         |  144 +-
 src/modules/OpenGL2/res.qrc              |   13 -
 src/modules/OpenGL2/resources.qrc        |   12 +
 24 files changed, 1964 insertions(+), 1851 deletions(-)
 delete mode 100644 src/modules/OpenGL2/GLSL/Bicubic.frag
 create mode 100644 src/modules/OpenGL2/OpenGL2.pro
 create mode 100644 src/modules/OpenGL2/OpenGL2CommonQt5.cpp
 create mode 100644 src/modules/OpenGL2/OpenGL2CommonQt5.hpp
 create mode 100644 src/modules/OpenGL2/OpenGL2OldWidget.cpp
 create mode 100644 src/modules/OpenGL2/OpenGL2OldWidget.hpp
 delete mode 100644 src/modules/OpenGL2/res.qrc
 create mode 100644 src/modules/OpenGL2/resources.qrc

diff --git a/src/modules/OpenGL2/CMakeLists.txt b/src/modules/OpenGL2/CMakeLists.txt
index 9a411b44..6e23a397 100644
--- a/src/modules/OpenGL2/CMakeLists.txt
+++ b/src/modules/OpenGL2/CMakeLists.txt
@@ -1,12 +1,24 @@
-cmake_minimum_required(VERSION 3.1)
+cmake_minimum_required(VERSION 2.8.6)
+if(COMMAND cmake_policy)
+    if(POLICY CMP0003)
+        cmake_policy(SET CMP0003 NEW)
+    endif()
+    if(POLICY CMP0020)
+        cmake_policy(SET CMP0020 NEW)
+    endif()
+    if(POLICY CMP0042)
+        cmake_policy(SET CMP0042 NEW)
+    endif()
+    if(POLICY CMP0043)
+        cmake_policy(SET CMP0043 NEW)
+    endif()
+endif()
 project(OpenGL2)
 
 set(OpenGL2_HDR
     OpenGL2.hpp
     OpenGL2Writer.hpp
     OpenGL2Common.hpp
-    OpenGL2Window.hpp
-    OpenGL2Widget.hpp
     Sphere.hpp
     Vertices.hpp
 )
@@ -15,22 +27,52 @@ set(OpenGL2_SRC
     OpenGL2.cpp
     OpenGL2Writer.cpp
     OpenGL2Common.cpp
-    OpenGL2Window.cpp
-    OpenGL2Widget.cpp
     Sphere.cpp
 )
 
 set(OpenGL2_RESOURCES
-    res.qrc
+    resources.qrc
 )
 
-if(NOT WIN32)
+function(gles1Error)
+    message(SEND_ERROR "OpenGL|ES 1.0 is not supported!")
+endfunction()
+
+if(USE_QT5)
     if(Qt5Gui_OPENGL_IMPLEMENTATION STREQUAL GLESv2)
         set(QT_USES_OPENGLES ON)
         add_definitions(-DOPENGL_ES2)
     elseif(Qt5Gui_OPENGL_IMPLEMENTATION STREQUAL GLES)
-        message(SEND_ERROR "OpenGL|ES 1.0 is not supported!")
+        gles1Error()
+    endif()
+else()
+    find_package(Qt4 REQUIRED QtOpenGL)
+    include(${QT_USE_FILE})
+    if(${QT_QCONFIG} MATCHES "opengles2")
+        set(QT_USES_OPENGLES ON)
+        add_definitions(-DOPENGL_ES2)
+    elseif(${QT_QCONFIG} MATCHES "opengles1")
+        gles1Error()
+    endif()
+endif()
+
+if(NOT USE_QT5 OR Qt5Widgets_VERSION LESS 5.6.0)
+    add_definitions(-DDONT_RECREATE_SHADERS)
+    list(APPEND OpenGL2_HDR OpenGL2OldWidget.hpp)
+    list(APPEND OpenGL2_SRC OpenGL2OldWidget.cpp)
+    if(NOT QT_USES_OPENGLES)
+        add_definitions(-DVSYNC_SETTINGS)
     endif()
+else()
+    add_definitions(-DOPENGL_NEW_API -DVSYNC_SETTINGS)
+    list(APPEND OpenGL2_HDR OpenGL2Window.hpp OpenGL2Widget.hpp OpenGL2CommonQt5.hpp)
+    list(APPEND OpenGL2_SRC OpenGL2Window.cpp OpenGL2Widget.cpp OpenGL2CommonQt5.cpp)
+endif()
+
+if(USE_QT5)
+    qt5_add_resources(OpenGL2_RESOURCES_RCC ${OpenGL2_RESOURCES})
+else()
+    qt4_add_resources(OpenGL2_RESOURCES_RCC ${OpenGL2_RESOURCES})
 endif()
 
 include_directories(../../qmplay2/headers)
@@ -38,11 +80,20 @@ include_directories(../../qmplay2/headers)
 add_library(${PROJECT_NAME} ${QMPLAY2_MODULE}
     ${OpenGL2_HDR}
     ${OpenGL2_SRC}
-    ${OpenGL2_RESOURCES}
+    ${OpenGL2_RESOURCES_RCC}
 )
 
+if(NOT USE_QT5) # Qt4
+    target_link_libraries(${PROJECT_NAME} Qt4::QtCore Qt4::QtGui Qt4::QtOpenGL)
+elseif(Qt5Widgets_VERSION LESS 5.6.0) # Qt5 < 5.6.0
+    qt5_use_modules(${PROJECT_NAME} Gui Widgets OpenGL)
+else() # Qt5 >= 5.6.0
+    qt5_use_modules(${PROJECT_NAME} Gui Widgets)
+endif()
+
+add_dependencies(${PROJECT_NAME} libqmplay2)
 target_link_libraries(${PROJECT_NAME}
-    libqmplay2
+    ${qmplay2lib}
 )
 
 if(APPLE)
diff --git a/src/modules/OpenGL2/GLSL/Bicubic.frag b/src/modules/OpenGL2/GLSL/Bicubic.frag
deleted file mode 100644
index b531397a..00000000
--- a/src/modules/OpenGL2/GLSL/Bicubic.frag
+++ /dev/null
@@ -1,67 +0,0 @@
-uniform int uBicubic;
-
-// w0, w1, w2, and w3 are the four cubic B-spline basis functions
-float w0(float a)
-{
-    return (1.0 / 6.0) * (a * (a * (-a + 3.0) - 3.0) + 1.0);
-}
-float w1(float a)
-{
-    return (1.0 / 6.0) * (a * a * (3.0 * a - 6.0) + 4.0);
-}
-float w2(float a)
-{
-    return (1.0 / 6.0) * (a * (a * (-3.0 * a + 3.0) + 3.0) + 1.0);
-}
-float w3(float a)
-{
-    return (1.0 / 6.0) * (a * a * a);
-}
-
-// g0 and g1 are the two amplitude functions
-float g0(float a)
-{
-    return w0(a) + w1(a);
-}
-float g1(float a)
-{
-    return w2(a) + w3(a);
-}
-
-// h0 and h1 are the two offset functions
-float h0(float a)
-{
-    return -1.0 + w1(a) / (w0(a) + w1(a));
-}
-float h1(float a)
-{
-    return 1.0 + w3(a) / (w2(a) + w3(a));
-}
-
-vec4 getTexel(sampler2D tex, vec2 st)
-{
-    if (uBicubic == 0)
-        return texture(tex, st);
-
-    st = st * uTextureSize + 0.5;
-
-    vec2 iSt = floor(st);
-    vec2 fSt = fract(st);
-
-    float g0x = g0(fSt.x);
-    float g1x = g1(fSt.x);
-    float g0y = g0(fSt.y);
-    float g1y = g1(fSt.y);
-    float h0x = h0(fSt.x);
-    float h1x = h1(fSt.x);
-    float h0y = h0(fSt.y);
-    float h1y = h1(fSt.y);
-
-    vec2 p0 = (vec2(iSt.x + h0x, iSt.y + h0y) - 0.5) / uTextureSize;
-    vec2 p1 = (vec2(iSt.x + h1x, iSt.y + h0y) - 0.5) / uTextureSize;
-    vec2 p2 = (vec2(iSt.x + h0x, iSt.y + h1y) - 0.5) / uTextureSize;
-    vec2 p3 = (vec2(iSt.x + h1x, iSt.y + h1y) - 0.5) / uTextureSize;
-
-    return g0y * (g0x * texture(tex, p0) + g1x * texture(tex, p1)) +
-           g1y * (g0x * texture(tex, p2) + g1x * texture(tex, p3));
-}
diff --git a/src/modules/OpenGL2/GLSL/VideoRGB.frag b/src/modules/OpenGL2/GLSL/VideoRGB.frag
index 47524888..50bc2141 100644
--- a/src/modules/OpenGL2/GLSL/VideoRGB.frag
+++ b/src/modules/OpenGL2/GLSL/VideoRGB.frag
@@ -1,16 +1,12 @@
-#define texture texture2D
-
 varying vec2 vTexCoord;
 uniform vec3 uVideoAdj;
-uniform vec2 uTextureSize;
+uniform vec2 uStep;
 uniform sampler2D uRGB;
 
-#define getTexel texture
-
 #ifdef Sharpness
 vec4 getRGBAtOffset(float x, float y)
 {
-    return getTexel(uRGB, vTexCoord + vec2(x, y));
+    return texture2D(uRGB, vTexCoord + vec2(x, y));
 }
 #endif
 
@@ -18,7 +14,7 @@ void main()
 {
     float brightness = uVideoAdj[0];
     float contrast = uVideoAdj[1];
-    vec4 RGB = getTexel(uRGB, vTexCoord);
+    vec4 RGB = texture2D(uRGB, vTexCoord);
 #ifdef Sharpness
     float sharpness = uVideoAdj[2];
     if (sharpness != 0.0)
@@ -27,15 +23,14 @@ void main()
         // 1 2 1
         // 2 4 2
         // 1 2 1
-        vec2 single = 1.0 / uTextureSize;
         vec4 blur = (
-            getRGBAtOffset(-single.x, -single.y) / 16.0 + getRGBAtOffset(0.0, -single.y) / 8.0 + getRGBAtOffset(single.x, -single.y) / 16.0 +
-            getRGBAtOffset(-single.x,  0.0     ) /  8.0 + RGB                            / 4.0 + getRGBAtOffset(single.x,  0.0     ) /  8.0 +
-            getRGBAtOffset(-single.x,  single.y) / 16.0 + getRGBAtOffset(0.0,  single.y) / 8.0 + getRGBAtOffset(single.x,  single.y) / 16.0
+            getRGBAtOffset(-uStep.x, -uStep.y) / 16.0 + getRGBAtOffset(0.0, -uStep.y) / 8.0 + getRGBAtOffset(uStep.x, -uStep.y) / 16.0 +
+            getRGBAtOffset(-uStep.x,  0.0    ) /  8.0 + getRGBAtOffset(0.0,  0.0    ) / 4.0 + getRGBAtOffset(uStep.x,  0.0    ) /  8.0 +
+            getRGBAtOffset(-uStep.x,  uStep.y) / 16.0 + getRGBAtOffset(0.0,  uStep.y) / 8.0 + getRGBAtOffset(uStep.x,  uStep.y) / 16.0
         );
         // Subtract blur from original image, multiply and then add it to the original image
         RGB = clamp(RGB + (RGB - blur) * sharpness, 0.0, 1.0);
     }
 #endif
-    gl_FragColor = clamp((RGB - 0.5) * contrast + 0.5, 0.0, 1.0) + brightness;
+    gl_FragColor = clamp(RGB * contrast, 0.0, 1.0) + brightness;
 }
diff --git a/src/modules/OpenGL2/GLSL/VideoYCbCr.frag b/src/modules/OpenGL2/GLSL/VideoYCbCr.frag
index 27032a2c..9bdb5c9b 100644
--- a/src/modules/OpenGL2/GLSL/VideoYCbCr.frag
+++ b/src/modules/OpenGL2/GLSL/VideoYCbCr.frag
@@ -1,8 +1,8 @@
 #ifdef TEXTURE_RECTANGLE
     #define sampler sampler2DRect
-    #define texCoordY  (vTexCoord * uTextureSize)
-    #define texCoordUV (vTexCoord * uTextureSize / 2.0)
-    #define texCoordYWithOffset(offset) ((vTexCoord + offset) * uTextureSize)
+    #define texCoordY  (vTexCoord / uStep)
+    #define texCoordUV (vTexCoord / uStep / 2.0)
+    #define texCoordYWithOffset(offset) ((vTexCoord + offset) / uStep)
     #define texture texture2DRect
 #else
     #define sampler sampler2D
@@ -13,11 +13,9 @@
 #endif
 
 varying vec2 vTexCoord;
-uniform mat3 uYUVtRGB;
-uniform float uBL;
 uniform vec4 uVideoEq;
 uniform float uSharpness;
-uniform vec2 uTextureSize;
+uniform vec2 uStep;
 uniform sampler uY;
 #ifdef NV12
     uniform sampler uCbCr;
@@ -25,12 +23,16 @@ uniform sampler uY;
     uniform sampler uCb, uCr;
 #endif
 
-#define getTexel texture
+const mat3 YUVtoRGB = mat3(
+    1.16430,  1.16430, 1.16430,
+    0.00000, -0.39173, 2.01700,
+    1.59580, -0.81290, 0.00000
+);
 
 #ifdef HueAndSharpness
 float getLumaAtOffset(float x, float y)
 {
-    return getTexel(uY, texCoordYWithOffset(vec2(x, y)))[0] - uBL;
+    return texture(uY, texCoordYWithOffset(vec2(x, y)))[0] - 0.0625;
 }
 #endif
 
@@ -45,17 +47,17 @@ void main()
 
 #ifdef NV12
     vec3 YCbCr = vec3(
-        getTexel(uY   , texCoordY )[0],
-        getTexel(uCbCr, texCoordUV).xy
+        texture(uY   , texCoordY )[0] - 0.0625,
+        texture(uCbCr, texCoordUV)[0] - 0.5,
+        texture(uCbCr, texCoordUV)[1] - 0.5
     );
 #else
     vec3 YCbCr = vec3(
-        getTexel(uY , texCoordY )[0],
-        getTexel(uCb, texCoordUV)[0],
-        getTexel(uCr, texCoordUV)[0]
+        texture(uY , texCoordY )[0] - 0.0625,
+        texture(uCb, texCoordUV)[0] - 0.5,
+        texture(uCr, texCoordUV)[0] - 0.5
     );
 #endif
-    YCbCr -= vec3(uBL, vec2(128.0 / 255.0));
 
 #ifdef HueAndSharpness
     if (uSharpness != 0.0)
@@ -64,11 +66,10 @@ void main()
         // 1 2 1
         // 2 4 2
         // 1 2 1
-        vec2 single = 1.0 / uTextureSize;
         float lumaBlur = (
-            getLumaAtOffset(-single.x, -single.y) / 16.0 + getLumaAtOffset(0.0, -single.y) / 8.0 + getLumaAtOffset(single.x, -single.y) / 16.0 +
-            getLumaAtOffset(-single.x,  0.0     ) /  8.0 + YCbCr[0]                        / 4.0 + getLumaAtOffset(single.x,  0.0     ) /  8.0 +
-            getLumaAtOffset(-single.x,  single.y) / 16.0 + getLumaAtOffset(0.0,  single.y) / 8.0 + getLumaAtOffset(single.x,  single.y) / 16.0
+            getLumaAtOffset(-uStep.x, -uStep.y) / 16.0 + getLumaAtOffset(0.0, -uStep.y) / 8.0 + getLumaAtOffset(uStep.x, -uStep.y) / 16.0 +
+            getLumaAtOffset(-uStep.x,  0.0    ) /  8.0 + getLumaAtOffset(0.0,  0.0    ) / 4.0 + getLumaAtOffset(uStep.x,  0.0    ) /  8.0 +
+            getLumaAtOffset(-uStep.x,  uStep.y) / 16.0 + getLumaAtOffset(0.0,  uStep.y) / 8.0 + getLumaAtOffset(uStep.x,  uStep.y) / 16.0
         );
         // Subtract blur from original image, multiply and then add it to the original image
         YCbCr[0] = clamp(YCbCr[0] + (YCbCr[0] - lumaBlur) * uSharpness, 0.0, 1.0);
@@ -84,5 +85,5 @@ void main()
     }
 #endif
 
-    gl_FragColor = vec4(clamp(uYUVtRGB * ((YCbCr - vec3(0.5, 0.0, 0.0)) * contrastSaturation + vec3(0.5, 0.0, 0.0)), 0.0, 1.0) + brightness, 1.0);
+    gl_FragColor = vec4(clamp(YUVtoRGB * (YCbCr * contrastSaturation), 0.0, 1.0) + brightness, 1.0);
 }
diff --git a/src/modules/OpenGL2/OpenGL2.cpp b/src/modules/OpenGL2/OpenGL2.cpp
index b52c76be..399887f8 100644
--- a/src/modules/OpenGL2/OpenGL2.cpp
+++ b/src/modules/OpenGL2/OpenGL2.cpp
@@ -1,60 +1,65 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include <OpenGL2.hpp>
 #include <OpenGL2Writer.hpp>
 
-#include <QGuiApplication>
+#ifdef OPENGL_NEW_API
+	#include <QGuiApplication>
+#endif
 
 OpenGL2::OpenGL2() :
-    Module("OpenGL2")
+	Module("OpenGL2")
 {
-    m_icon = QIcon(":/OpenGL2.svgz");
-
-    init("Enabled", true);
-    init("AllowPBO", true);
-    init("HQScaling", false);
-    const QString platformName = QGuiApplication::platformName();
-    init("ForceRtt", (platformName == "cocoa" || platformName == "android"));
-    init("VSync", true);
+	m_icon = QIcon(":/OpenGL2.svgz");
+
+	init("Enabled", true);
+	init("AllowPBO", true);
+#ifdef OPENGL_NEW_API
+	const QString platformName = QGuiApplication::platformName();
+	init("ForceRtt", (platformName == "cocoa" || platformName == "android"));
+#endif
+#ifdef VSYNC_SETTINGS
+	init("VSync", true);
+#endif
 #ifdef Q_OS_WIN
-    if (QSysInfo::windowsVersion() >= QSysInfo::WV_6_0)
-        init("PreventFullScreen", true);
+	if (QSysInfo::windowsVersion() >= QSysInfo::WV_6_0)
+		init("PreventFullScreen", true);
 #endif
 }
 
 QList<OpenGL2::Info> OpenGL2::getModulesInfo(const bool showDisabled) const
 {
-    QList<Info> modulesInfo;
-    if (showDisabled || getBool("Enabled"))
-        modulesInfo += Info(OpenGL2WriterName, WRITER, QStringList{"video"});
-    return modulesInfo;
+	QList<Info> modulesInfo;
+	if (showDisabled || getBool("Enabled"))
+		modulesInfo += Info(OpenGL2WriterName, WRITER, QStringList{"video"});
+	return modulesInfo;
 }
 void *OpenGL2::createInstance(const QString &name)
 {
-    if (name == OpenGL2WriterName && getBool("Enabled"))
-        return new OpenGL2Writer(*this);
-    return nullptr;
+	if (name == OpenGL2WriterName && getBool("Enabled"))
+		return new OpenGL2Writer(*this);
+	return nullptr;
 }
 
 OpenGL2::SettingsWidget *OpenGL2::getSettingsWidget()
 {
-    return new ModuleSettingsWidget(*this);
+	return new ModuleSettingsWidget(*this);
 }
 
 QMPLAY2_EXPORT_MODULE(OpenGL2)
@@ -65,58 +70,64 @@ QMPLAY2_EXPORT_MODULE(OpenGL2)
 #include <QCheckBox>
 
 ModuleSettingsWidget::ModuleSettingsWidget(Module &module) :
-    Module::SettingsWidget(module)
+	Module::SettingsWidget(module)
 {
-    enabledB = new QCheckBox(tr("Enabled"));
-    enabledB->setChecked(sets().getBool("Enabled"));
-
-    allowPboB = new QCheckBox(tr("Allow to use PBO (if available)"));
-    allowPboB->setChecked(sets().getBool("AllowPBO"));
+	enabledB = new QCheckBox(tr("Enabled"));
+	enabledB->setChecked(sets().getBool("Enabled"));
 
-    hqScalingB = new QCheckBox(tr("High quality video scaling"));
-    hqScalingB->setToolTip(tr("Trilinear filtering for minification and bicubic filtering for magnification."));
-    hqScalingB->setChecked(sets().getBool("HQScaling"));
+	allowPboB = new QCheckBox(tr("Allow to use PBO (if available)"));
+	allowPboB->setChecked(sets().getBool("AllowPBO"));
 
-    forceRttB = new QCheckBox(tr("Force render to texture if possible (not recommended)"));
-    forceRttB->setToolTip(tr("Always enabled on Wayland and Android platforms.\nSet visualizations to OpenGL mode if enabled."));
-    forceRttB->setChecked(sets().getBool("ForceRtt"));
+#ifdef OPENGL_NEW_API
+	forceRttB = new QCheckBox(tr("Force render to texture if possible (not recommended)"));
+	forceRttB->setToolTip(tr("Always enabled on Wayland and Android platforms.\nSet visualizations to OpenGL mode if enabled."));
+	forceRttB->setChecked(sets().getBool("ForceRtt"));
+#endif
 
-    vsyncB = new QCheckBox(tr("Vertical sync") +  " (VSync)");
-    vsyncB->setChecked(sets().getBool("VSync"));
+#ifdef VSYNC_SETTINGS
+	vsyncB = new QCheckBox(tr("Vertical sync") +  " (VSync)");
+	vsyncB->setChecked(sets().getBool("VSync"));
+#endif
 
 #ifdef Q_OS_WIN
-    if (QSysInfo::windowsVersion() >= QSysInfo::WV_6_0)
-    {
-        preventFullScreenB = new QCheckBox(tr("Try to prevent exclusive full screen"));
-        preventFullScreenB->setChecked(sets().getBool("PreventFullScreen"));
-    }
-    else
-    {
-        preventFullScreenB = nullptr;
-    }
+	if (QSysInfo::windowsVersion() >= QSysInfo::WV_6_0)
+	{
+		preventFullScreenB = new QCheckBox(tr("Try to prevent exclusive full screen"));
+		preventFullScreenB->setChecked(sets().getBool("PreventFullScreen"));
+	}
+	else
+	{
+		preventFullScreenB = nullptr;
+	}
 #endif
 
-    QGridLayout *layout = new QGridLayout(this);
-    layout->addWidget(enabledB);
-    layout->addWidget(allowPboB);
-    layout->addWidget(hqScalingB);
-    layout->addWidget(forceRttB);
-    layout->addWidget(vsyncB);
+	QGridLayout *layout = new QGridLayout(this);
+	layout->addWidget(enabledB);
+	layout->addWidget(allowPboB);
+#ifdef OPENGL_NEW_API
+	layout->addWidget(forceRttB);
+#endif
+#ifdef VSYNC_SETTINGS
+	layout->addWidget(vsyncB);
+#endif
 #ifdef Q_OS_WIN
-    if (preventFullScreenB)
-        layout->addWidget(preventFullScreenB);
+	if (preventFullScreenB)
+		layout->addWidget(preventFullScreenB);
 #endif
 }
 
 void ModuleSettingsWidget::saveSettings()
 {
-    sets().set("Enabled", enabledB->isChecked());
-    sets().set("AllowPBO", allowPboB->isChecked());
-    sets().set("HQScaling", hqScalingB->isChecked());
-    sets().set("ForceRtt", forceRttB->isChecked());
-    sets().set("VSync", vsyncB->isChecked());
+	sets().set("Enabled", enabledB->isChecked());
+	sets().set("AllowPBO", allowPboB->isChecked());
+#ifdef OPENGL_NEW_API
+	sets().set("ForceRtt", forceRttB->isChecked());
+#endif
+#ifdef VSYNC_SETTINGS
+	sets().set("VSync", vsyncB->isChecked());
+#endif
 #ifdef Q_OS_WIN
-    if (preventFullScreenB)
-        sets().set("PreventFullScreen", preventFullScreenB->isChecked());
+	if (preventFullScreenB)
+		sets().set("PreventFullScreen", preventFullScreenB->isChecked());
 #endif
 }
diff --git a/src/modules/OpenGL2/OpenGL2.hpp b/src/modules/OpenGL2/OpenGL2.hpp
index 89f22d21..7a306f1a 100644
--- a/src/modules/OpenGL2/OpenGL2.hpp
+++ b/src/modules/OpenGL2/OpenGL2.hpp
@@ -1,34 +1,34 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
 
 #include <Module.hpp>
 
-class OpenGL2 final : public Module
+class OpenGL2 : public Module
 {
 public:
-    OpenGL2();
+	OpenGL2();
 private:
-    QList<Info> getModulesInfo(const bool) const override;
-    void *createInstance(const QString &) override;
+	QList<Info> getModulesInfo(const bool) const override final;
+	void *createInstance(const QString &) override final;
 
-    SettingsWidget *getSettingsWidget() override;
+	SettingsWidget *getSettingsWidget() override final;
 };
 
 /**/
@@ -37,18 +37,22 @@ private:
 
 class QCheckBox;
 
-class ModuleSettingsWidget final : public Module::SettingsWidget
+class ModuleSettingsWidget : public Module::SettingsWidget
 {
-    Q_DECLARE_TR_FUNCTIONS(ModuleSettingsWidget)
+	Q_DECLARE_TR_FUNCTIONS(ModuleSettingsWidget)
 public:
-    ModuleSettingsWidget(Module &);
+	ModuleSettingsWidget(Module &);
 private:
-    void saveSettings() override;
+	void saveSettings() override final;
 
-    QCheckBox *enabledB, *allowPboB, *hqScalingB;
-    QCheckBox *forceRttB;
-    QCheckBox *vsyncB;
+	QCheckBox *enabledB, *allowPboB;
+#ifdef OPENGL_NEW_API
+	QCheckBox *forceRttB;
+#endif
+#ifdef VSYNC_SETTINGS
+	QCheckBox *vsyncB;
+#endif
 #ifdef Q_OS_WIN
-    QCheckBox *preventFullScreenB;
+	QCheckBox *preventFullScreenB;
 #endif
 };
diff --git a/src/modules/OpenGL2/OpenGL2.pro b/src/modules/OpenGL2/OpenGL2.pro
new file mode 100644
index 00000000..eac00026
--- /dev/null
+++ b/src/modules/OpenGL2/OpenGL2.pro
@@ -0,0 +1,35 @@
+TEMPLATE = lib
+CONFIG += plugin
+
+QT += widgets
+
+DESTDIR = ../../../app/lib/qmplay2/modules
+QMAKE_LIBDIR += ../../../app/lib
+
+LIBS += -lqmplay2
+
+RCC_DIR = build/rcc
+OBJECTS_DIR = build/obj
+MOC_DIR = build/moc
+
+RESOURCES += resources.qrc
+
+INCLUDEPATH += . ../../qmplay2/headers
+DEPENDPATH += . ../../qmplay2/headers
+
+HEADERS += OpenGL2.hpp OpenGL2Writer.hpp OpenGL2Common.hpp Sphere.hpp Vertices.hpp
+SOURCES += OpenGL2.cpp OpenGL2Writer.cpp OpenGL2Common.cpp Sphere.cpp
+
+equals(QT_VERSION, 5.6.0)|greaterThan(QT_VERSION, 5.6.0) {
+	DEFINES += OPENGL_NEW_API VSYNC_SETTINGS
+	HEADERS += OpenGL2Window.hpp OpenGL2Widget.hpp OpenGL2CommonQt5.hpp
+	SOURCES += OpenGL2Window.cpp OpenGL2Widget.cpp OpenGL2CommonQt5.cpp
+} else {
+	QT += opengl
+	DEFINES += DONT_RECREATE_SHADERS
+	HEADERS += OpenGL2OldWidget.hpp
+	SOURCES += OpenGL2OldWidget.cpp
+	unix:!android:!contains(QT_CONFIG, opengles2): DEFINES += VSYNC_SETTINGS
+}
+
+contains(QT_CONFIG, opengles2): DEFINES += OPENGL_ES2
diff --git a/src/modules/OpenGL2/OpenGL2Common.cpp b/src/modules/OpenGL2/OpenGL2Common.cpp
index a5c451d9..8a43b64a 100644
--- a/src/modules/OpenGL2/OpenGL2Common.cpp
+++ b/src/modules/OpenGL2/OpenGL2Common.cpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include <OpenGL2Common.hpp>
@@ -26,12 +26,17 @@
 #include <VideoFrame.hpp>
 #include <Functions.hpp>
 
-#include <QOffscreenSurface>
-#include <QOpenGLContext>
-#include <QOpenGLShader>
+#ifdef OPENGL_NEW_API
+	#include <QOpenGLContext>
+	#include <QOpenGLShader>
+#else
+	#include <QGLContext>
+	#include <QGLShader>
+	#define QOpenGLContext QGLContext
+	#define QOpenGLShader QGLShader
+#endif
 #include <QResizeEvent>
 #include <QMatrix4x4>
-#include <QMatrix3x3>
 #include <QResource>
 #include <QPainter>
 #include <QWidget>
@@ -40,1098 +45,984 @@
 
 /* OpenGL|ES 2.0 doesn't have those definitions */
 #ifndef GL_MAP_WRITE_BIT
-    #define GL_MAP_WRITE_BIT 0x0002
+	#define GL_MAP_WRITE_BIT 0x0002
 #endif
 #ifndef GL_MAP_INVALIDATE_BUFFER_BIT
-    #define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
+	#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
 #endif
 #ifndef GL_WRITE_ONLY
-    #define GL_WRITE_ONLY 0x88B9
+	#define GL_WRITE_ONLY 0x88B9
 #endif
 #ifndef GL_PIXEL_UNPACK_BUFFER
-    #define GL_PIXEL_UNPACK_BUFFER 0x88EC
+	#define GL_PIXEL_UNPACK_BUFFER 0x88EC
 #endif
 #ifndef GL_R8
-    #define GL_R8 0x8229
+	#define GL_R8 0x8229
 #endif
 #ifndef GL_RG8
-    #define GL_RG8 0x822B
+	#define GL_RG8 0x822B
 #endif
 #ifndef GL_RED
-    #define GL_RED 0x1903
+	#define GL_RED 0x1903
 #endif
 #ifndef GL_RG
-    #define GL_RG 0x8227
+	#define GL_RG 0x8227
 #endif
 #ifndef GL_TEXTURE_RECTANGLE_ARB
-    #define GL_TEXTURE_RECTANGLE_ARB 0x84F5
+	#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
 #endif
 
 /* RotAnimation */
 
 void RotAnimation::updateCurrentValue(const QVariant &value)
 {
-    if (!glCommon.buttonPressed)
-    {
-        const QPointF newRot = value.toPointF();
-        glCommon.rot.setX(qBound<qreal>(0.0, newRot.x(), 180.0));
-        glCommon.rot.setY(newRot.y());
-        glCommon.setMatrix = true;
-        glCommon.updateGL(true);
-    }
+	if (!glCommon.buttonPressed)
+	{
+		const QPointF newRot = value.toPointF();
+		glCommon.rot.setX(qBound<qreal>(0.0, newRot.x(), 180.0));
+		glCommon.rot.setY(newRot.y());
+		glCommon.setMatrix = true;
+		glCommon.updateGL(true);
+	}
 }
 
 /* OpenGLCommon implementation */
 
 OpenGL2Common::OpenGL2Common() :
 #ifndef OPENGL_ES2
-    supportsShaders(false), canCreateNonPowerOfTwoTextures(false),
-    glActiveTexture(nullptr),
+	supportsShaders(false), canCreateNonPowerOfTwoTextures(false),
+	glActiveTexture(nullptr),
+#endif
+#ifdef VSYNC_SETTINGS
+	vSync(true),
 #endif
-    vSync(true),
-    hwAccellnterface(nullptr),
-    shaderProgramVideo(nullptr), shaderProgramOSD(nullptr),
-    texCoordYCbCrLoc(-1), positionYCbCrLoc(-1), texCoordOSDLoc(-1), positionOSDLoc(-1),
-    numPlanes(0),
-    target(0),
-    Deinterlace(0),
-    allowPBO(true), hasPbo(false),
+	hwAccellnterface(nullptr),
+	shaderProgramVideo(nullptr), shaderProgramOSD(nullptr),
+	texCoordYCbCrLoc(-1), positionYCbCrLoc(-1), texCoordOSDLoc(-1), positionOSDLoc(-1),
+	numPlanes(0),
+	target(0),
+	Deinterlace(0),
+	allowPBO(true), hasPbo(false),
 #ifdef Q_OS_WIN
-    preventFullScreen(false),
+	preventFullScreen(false),
 #endif
-    isPaused(false), isOK(false), hwAccelError(false), hasImage(false), doReset(true), setMatrix(true), correctLinesize(false), canUseHueSharpness(true),
-    subsX(-1), subsY(-1), W(-1), H(-1), subsW(-1), subsH(-1), outW(-1), outH(-1), verticesIdx(0),
-    glVer(0),
-    aspectRatio(0.0), zoom(0.0),
-    sphericalView(false), buttonPressed(false), hasVbo(true), mouseWrapped(false), canWrapMouse(true),
-    rotAnimation(*this),
-    nIndices(0),
-    mouseTime(0.0)
+	isPaused(false), isOK(false), hwAccelError(false), hasImage(false), doReset(true), setMatrix(true), correctLinesize(false), canUseHueSharpness(true),
+	subsX(-1), subsY(-1), W(-1), H(-1), subsW(-1), subsH(-1), outW(-1), outH(-1), verticesIdx(0),
+	glVer(0),
+	aspectRatio(0.0), zoom(0.0),
+	sphericalView(false), buttonPressed(false), hasVbo(true), mouseWrapped(false), canWrapMouse(true),
+	rotAnimation(*this),
+	nIndices(0),
+	mouseTime(0.0)
 {
-    videoAdjustment.unset();
+	videoAdjustment.unset();
 
-    /* Initialize texCoordYCbCr array */
-    texCoordYCbCr[0] = texCoordYCbCr[4] = texCoordYCbCr[5] = texCoordYCbCr[7] = 0.0f;
-    texCoordYCbCr[1] = texCoordYCbCr[3] = 1.0f;
+	/* Initialize texCoordYCbCr array */
+	texCoordYCbCr[0] = texCoordYCbCr[4] = texCoordYCbCr[5] = texCoordYCbCr[7] = 0.0f;
+	texCoordYCbCr[1] = texCoordYCbCr[3] = 1.0f;
 
-    /* Set 360° view */
-    rotAnimation.setEasingCurve(QEasingCurve::OutQuint);
-    rotAnimation.setDuration(1000.0);
+	/* Set 360° view */
+	rotAnimation.setEasingCurve(QEasingCurve::OutQuint);
+	rotAnimation.setDuration(1000.0);
 }
 OpenGL2Common::~OpenGL2Common()
 {
-    contextAboutToBeDestroyed();
-    delete shaderProgramVideo;
-    delete shaderProgramOSD;
+	contextAboutToBeDestroyed();
+	delete shaderProgramVideo;
+	delete shaderProgramOSD;
 }
 
 void OpenGL2Common::deleteMe()
 {
-    delete this;
-}
-
-bool OpenGL2Common::testGL()
-{
-    QOpenGLContext glCtx;
-    if ((isOK = glCtx.create()))
-    {
-        QOffscreenSurface offscreenSurface;
-        offscreenSurface.create();
-        if ((isOK = glCtx.makeCurrent(&offscreenSurface)))
-            testGLInternal();
-    }
-    return isOK;
+	delete this;
 }
 
 void OpenGL2Common::newSize(const QSize &size)
 {
-    const bool canUpdate = !size.isValid();
-    const QSize winSize = canUpdate ? widget()->size() : size;
-    const qreal dpr = widget()->devicePixelRatioF();
-    if (!isRotate90())
-    {
-        Functions::getImageSize(aspectRatio, zoom, winSize.width(), winSize.height(), W, H, &subsX, &subsY);
-        Functions::getImageSize(aspectRatio, zoom, winSize.width() * dpr, winSize.height() * dpr, subsW, subsH, &subsX, &subsY);
-    }
-    else
-    {
-        Functions::getImageSize(aspectRatio, zoom, winSize.height(), winSize.width(), H, W);
-        Functions::getImageSize(aspectRatio, zoom, winSize.width() * dpr, winSize.height() * dpr, subsW, subsH, &subsX, &subsY);
-    }
-    doReset = true;
-    if (canUpdate)
-    {
-        if (isPaused)
-            updateGL(false);
-        else if (!updateTimer.isActive())
-            updateTimer.start(40);
-    }
+	const bool canUpdate = !size.isValid();
+	const QSize winSize = canUpdate ? widget()->size() : size;
+	const qreal scale = QMPlay2Core.getVideoDevicePixelRatio();
+	if (!isRotate90())
+	{
+		Functions::getImageSize(aspectRatio, zoom, winSize.width(), winSize.height(), W, H, &subsX, &subsY);
+		Functions::getImageSize(aspectRatio, zoom, winSize.width() * scale, winSize.height() * scale, subsW, subsH, &subsX, &subsY);
+	}
+	else
+	{
+		Functions::getImageSize(aspectRatio, zoom, winSize.height(), winSize.width(), H, W);
+		Functions::getImageSize(aspectRatio, zoom, winSize.width() * scale, winSize.height() * scale, subsW, subsH, &subsX, &subsY);
+	}
+	doReset = true;
+	if (canUpdate)
+	{
+		if (isPaused)
+			updateGL(false);
+		else if (!updateTimer.isActive())
+			updateTimer.start(40);
+	}
 }
 void OpenGL2Common::clearImg()
 {
-    hasImage = false;
-    osdImg = QImage();
-    videoFrame.clear();
-    osd_ids.clear();
+	hasImage = false;
+	osdImg = QImage();
+	videoFrame.clear();
+	osd_ids.clear();
 }
 
 void OpenGL2Common::setSpherical(bool spherical)
 {
-    const bool isSphericalView = (spherical && hasVbo);
-    if (sphericalView != isSphericalView)
-    {
-        QWidget *w = widget();
-        const bool isBlankCursor = (w->cursor().shape() == Qt::BlankCursor);
-        sphericalView = isSphericalView;
-        if (sphericalView)
-        {
-            w->setProperty("customCursor", (int)Qt::OpenHandCursor);
-            if (!isBlankCursor)
-                w->setCursor(Qt::OpenHandCursor);
-            rot = QPointF(90.0, 90.0);
-        }
-        else
-        {
-            w->setProperty("customCursor", QVariant());
-            if (!isBlankCursor)
-                w->setCursor(Qt::ArrowCursor);
-            buttonPressed = false;
-        }
-    }
+	const bool isSphericalView = (spherical && hasVbo);
+	if (sphericalView != isSphericalView)
+	{
+		QWidget *w = widget();
+		const bool isBlankCursor = (w->cursor().shape() == Qt::BlankCursor);
+		sphericalView = isSphericalView;
+		if (sphericalView)
+		{
+			w->setProperty("customCursor", (int)Qt::OpenHandCursor);
+			if (!isBlankCursor)
+				w->setCursor(Qt::OpenHandCursor);
+			rot = QPointF(90.0, 90.0);
+		}
+		else
+		{
+			w->setProperty("customCursor", QVariant());
+			if (!isBlankCursor)
+				w->setCursor(Qt::ArrowCursor);
+			buttonPressed = false;
+		}
+	}
 }
 
 void OpenGL2Common::initializeGL()
 {
-    if (!initGLProc())
-    {
-        isOK = false;
-        return;
-    }
-
+	initGLProc();
 #ifndef OPENGL_ES2
-    if (!glActiveTexture) //Be sure that "glActiveTexture" has valid pointer (don't check "supportsShaders" here)!
-    {
-        showOpenGLMissingFeaturesMessage();
-        isOK = false;
-        return;
-    }
+	if (!glActiveTexture) //Be sure that "glActiveTexture" has valid pointer (don't check "supportsShaders" here)!
+	{
+		showOpenGLMissingFeaturesMessage();
+		isOK = false;
+		return;
+	}
 #endif
 
-    delete shaderProgramVideo;
-    delete shaderProgramOSD;
-    shaderProgramVideo = new QOpenGLShaderProgram;
-    shaderProgramOSD = new QOpenGLShaderProgram;
-
-    /* YCbCr shader */
-    shaderProgramVideo->addShaderFromSourceCode(QOpenGLShader::Vertex, readShader(":/Video.vert"));
-    QByteArray videoFrag;
-    if (numPlanes == 1)
-    {
-        videoFrag = readShader(":/VideoRGB.frag");
-        if (canUseHueSharpness)
-        {
-            //Use sharpness only when OpenGL/OpenGL|ES version >= 3.0, because it can be slow on old hardware and/or buggy drivers and may increase CPU usage!
-            videoFrag.prepend("#define Sharpness\n");
-        }
-    }
-    else
-    {
-        videoFrag = readShader(":/VideoYCbCr.frag");
-        if (canUseHueSharpness)
-        {
-            //Use hue and sharpness only when OpenGL/OpenGL|ES version >= 3.0, because it can be slow on old hardware and/or buggy drivers and may increase CPU usage!
-            videoFrag.prepend("#define HueAndSharpness\n");
-        }
-        if (numPlanes == 2)
-            videoFrag.prepend("#define NV12\n");
-    }
-    if (target == GL_TEXTURE_RECTANGLE_ARB)
-        videoFrag.prepend("#define TEXTURE_RECTANGLE\n");
-    if (hqScaling)
-    {
-        constexpr const char *getTexelDefine = "#define getTexel texture\n";
-        Q_ASSERT(videoFrag.contains(getTexelDefine));
-        videoFrag.replace(getTexelDefine, readShader(":/Bicubic.frag", true));
-    }
-    shaderProgramVideo->addShaderFromSourceCode(QOpenGLShader::Fragment, videoFrag);
-    if (shaderProgramVideo->bind())
-    {
-        texCoordYCbCrLoc = shaderProgramVideo->attributeLocation("aTexCoord");
-        positionYCbCrLoc = shaderProgramVideo->attributeLocation("aPosition");
-        shaderProgramVideo->setUniformValue((numPlanes == 1) ? "uRGB" : "uY" , 0);
-        if (numPlanes == 2)
-            shaderProgramVideo->setUniformValue("uCbCr", 1);
-        else if (numPlanes == 3)
-        {
-            shaderProgramVideo->setUniformValue("uCb", 1);
-            shaderProgramVideo->setUniformValue("uCr", 2);
-        }
-        shaderProgramVideo->release();
-    }
-    else
-    {
-        QMPlay2Core.logError(tr("Shader compile/link error"));
-        isOK = false;
-        return;
-    }
-
-    /* OSD shader */
-    shaderProgramOSD->addShaderFromSourceCode(QOpenGLShader::Vertex, readShader(":/OSD.vert"));
-    shaderProgramOSD->addShaderFromSourceCode(QOpenGLShader::Fragment, readShader(":/OSD.frag"));
-    if (shaderProgramOSD->bind())
-    {
-        texCoordOSDLoc = shaderProgramOSD->attributeLocation("aTexCoord");
-        positionOSDLoc = shaderProgramOSD->attributeLocation("aPosition");
-        shaderProgramOSD->setUniformValue("uTex", 3);
-        shaderProgramOSD->release();
-    }
-    else
-    {
-        QMPlay2Core.logError(tr("Shader compile/link error"));
-        isOK = false;
-        return;
-    }
-
-    /* Set OpenGL parameters */
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glClearColor(0.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glDisable(GL_STENCIL_TEST);
-    glDisable(GL_DEPTH_TEST);
-    glDisable(GL_DITHER);
-
-    /* Prepare textures */
-    glGenTextures(numPlanes + 1, textures);
-    for (int i = 0; i < numPlanes + 1; ++i)
-    {
-        const quint32 tmpTarget = (i == 0) ? GL_TEXTURE_2D : target;
-        qint32 tmpParam  = (i == 0) ? GL_NEAREST : GL_LINEAR;
-        glBindTexture(tmpTarget, textures[i]);
-        glTexParameteri(tmpTarget, GL_TEXTURE_MIN_FILTER, tmpParam);
-        glTexParameteri(tmpTarget, GL_TEXTURE_MAG_FILTER, tmpParam);
-        glTexParameteri(tmpTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-        glTexParameteri(tmpTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    }
-
-    if (hasPbo)
-    {
-        glGenBuffers(1 + (hwAccellnterface ? 0 : numPlanes), pbo);
-        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-    }
-
-    setVSync(vSync);
-
-    doReset = true;
-    resetSphereVbo();
+#ifndef DONT_RECREATE_SHADERS
+	delete shaderProgramVideo;
+	delete shaderProgramOSD;
+	shaderProgramVideo = shaderProgramOSD = nullptr;
+#endif
+	if (!shaderProgramVideo)
+		shaderProgramVideo = new QOpenGLShaderProgram;
+	if (!shaderProgramOSD)
+		shaderProgramOSD = new QOpenGLShaderProgram;
+
+	/* YCbCr shader */
+	if (shaderProgramVideo->shaders().isEmpty())
+	{
+		shaderProgramVideo->addShaderFromSourceCode(QOpenGLShader::Vertex, readShader(":/Video.vert"));
+		QByteArray VideoFrag;
+		if (numPlanes == 1)
+		{
+			VideoFrag = readShader(":/VideoRGB.frag");
+			if (canUseHueSharpness)
+			{
+				//Use sharpness only when OpenGL/OpenGL|ES version >= 3.0, because it can be slow on old hardware and/or buggy drivers and may increase CPU usage!
+				VideoFrag.prepend("#define Sharpness\n");
+			}
+		}
+		else
+		{
+			VideoFrag = readShader(":/VideoYCbCr.frag");
+			if (canUseHueSharpness)
+			{
+				//Use hue and sharpness only when OpenGL/OpenGL|ES version >= 3.0, because it can be slow on old hardware and/or buggy drivers and may increase CPU usage!
+				VideoFrag.prepend("#define HueAndSharpness\n");
+			}
+			if (numPlanes == 2)
+				VideoFrag.prepend("#define NV12\n");
+		}
+		if (target == GL_TEXTURE_RECTANGLE_ARB)
+			VideoFrag.prepend("#define TEXTURE_RECTANGLE\n");
+		shaderProgramVideo->addShaderFromSourceCode(QOpenGLShader::Fragment, VideoFrag);
+	}
+	if (shaderProgramVideo->bind())
+	{
+		const qint32 newTexCoordLoc = shaderProgramVideo->attributeLocation("aTexCoord");
+		const qint32 newPositionLoc = shaderProgramVideo->attributeLocation("aPosition");
+		if (newTexCoordLoc != newPositionLoc) //If new locations are invalid, just leave them untouched...
+		{
+			texCoordYCbCrLoc = newTexCoordLoc;
+			positionYCbCrLoc = newPositionLoc;
+		}
+		shaderProgramVideo->setUniformValue((numPlanes == 1) ? "uRGB" : "uY" , 0);
+		if (numPlanes == 2)
+			shaderProgramVideo->setUniformValue("uCbCr", 1);
+		else if (numPlanes == 3)
+		{
+			shaderProgramVideo->setUniformValue("uCb", 1);
+			shaderProgramVideo->setUniformValue("uCr", 2);
+		}
+		shaderProgramVideo->release();
+	}
+	else
+	{
+		QMPlay2Core.logError(tr("Shader compile/link error"));
+		isOK = false;
+		return;
+	}
+
+	/* OSD shader */
+	if (shaderProgramOSD->shaders().isEmpty())
+	{
+		shaderProgramOSD->addShaderFromSourceCode(QOpenGLShader::Vertex, readShader(":/OSD.vert"));
+		shaderProgramOSD->addShaderFromSourceCode(QOpenGLShader::Fragment, readShader(":/OSD.frag"));
+	}
+	if (shaderProgramOSD->bind())
+	{
+		const qint32 newTexCoordLoc = shaderProgramOSD->attributeLocation("aTexCoord");
+		const qint32 newPositionLoc = shaderProgramOSD->attributeLocation("aPosition");
+		if (newTexCoordLoc != newPositionLoc) //If new locations are invalid, just leave them untouched...
+		{
+			texCoordOSDLoc = newTexCoordLoc;
+			positionOSDLoc = newPositionLoc;
+		}
+		shaderProgramOSD->setUniformValue("uTex", 3);
+		shaderProgramOSD->release();
+	}
+	else
+	{
+		QMPlay2Core.logError(tr("Shader compile/link error"));
+		isOK = false;
+		return;
+	}
+
+	/* Set OpenGL parameters */
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	glClearColor(0.0, 0.0, 0.0, 1.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+	glDisable(GL_STENCIL_TEST);
+	glDisable(GL_DEPTH_TEST);
+	glDisable(GL_DITHER);
+
+	/* Prepare textures */
+	glGenTextures(numPlanes + 1, textures);
+	for (int i = 0; i < numPlanes + 1; ++i)
+	{
+		const quint32 tmpTarget = (i == 0) ? GL_TEXTURE_2D : target;
+		qint32 tmpParam  = (i == 0) ? GL_NEAREST : GL_LINEAR;
+		glBindTexture(tmpTarget, textures[i]);
+		glTexParameteri(tmpTarget, GL_TEXTURE_MIN_FILTER, tmpParam);
+		glTexParameteri(tmpTarget, GL_TEXTURE_MAG_FILTER, tmpParam);
+		glTexParameteri(tmpTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(tmpTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	}
+
+	if (hasPbo)
+	{
+		glGenBuffers(1 + (hwAccellnterface ? 0 : numPlanes), pbo);
+		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+	}
+
+#ifdef VSYNC_SETTINGS
+	setVSync(vSync);
+#endif
+
+	doReset = true;
+	resetSphereVbo();
 }
 
 void OpenGL2Common::paintGL()
 {
-    const bool frameIsEmpty = videoFrame.isEmpty();
-
-    if (updateTimer.isActive())
-        updateTimer.stop();
-
-    if (frameIsEmpty && !hasImage)
-        return;
-
-    const QSize winSize = widget()->size();
-
-    bool resetDone = false;
-
-    if (!frameIsEmpty && hwAccellPossibleLock())
-    {
-        const GLsizei widths[3] = {
-            videoFrame.size.width,
-            videoFrame.size.chromaWidth(),
-            videoFrame.size.chromaWidth(),
-        };
-        const GLsizei heights[3] = {
-            videoFrame.size.height,
-            videoFrame.size.chromaHeight(),
-            videoFrame.size.chromaHeight()
-        };
-
-        if (doReset)
-        {
-            if (hwAccellnterface)
-            {
-                /* Release HWAccell resources */
-                hwAccellnterface->clear(false);
-
-                if (hwAccellnterface->canInitializeTextures())
-                {
-                    if (numPlanes == 2)
-                    {
-                        //NV12
-                        for (int p = 0; p < 2; ++p)
-                        {
-                            glBindTexture(target, textures[p + 1]);
-                            glTexImage2D(target, 0, !p ? GL_R8 : GL_RG8, widths[p], heights[p], 0, !p ? GL_RED : GL_RG, GL_UNSIGNED_BYTE, nullptr);
-                        }
-                    }
-                    else if (numPlanes == 1)
-                    {
-                        //RGB32
-                        glBindTexture(target, textures[1]);
-                        glTexImage2D(target, 0, GL_RGBA, widths[0], heights[0], 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
-                    }
-                }
-
-                m_textureSize = QSize(widths[0], heights[0]);
-
-                if (hqScaling)
-                {
-                    // Must be set before "HWAccelInterface::init()" and must have "m_textureSize"
-                    maybeSetMipmaps(widget()->devicePixelRatioF());
-                }
-
-                /* Prepare textures, register GL textures */
-                const bool hasHwAccelError = hwAccelError;
-                hwAccelError = !hwAccellnterface->init(&textures[1]);
-                if (hwAccelError && !hasHwAccelError)
-                    QMPlay2Core.logError("OpenGL 2 :: " + tr("Can't init textures for") + " " + hwAccellnterface->name());
-
-
-                /* Prepare texture coordinates */
-                texCoordYCbCr[2] = texCoordYCbCr[6] = 1.0f;
-            }
-            else
-            {
-                /* Check linesize */
-                const qint32 halfLinesize = (videoFrame.linesize[0] >> videoFrame.size.chromaShiftW);
-                correctLinesize =
-                (
-                    (halfLinesize == videoFrame.linesize[1] && videoFrame.linesize[1] == videoFrame.linesize[2]) &&
-                    (!sphericalView ? (videoFrame.linesize[1] == halfLinesize) : (videoFrame.linesize[0] == widths[0]))
-                );
-
-                /* Prepare textures */
-                for (qint32 p = 0; p < 3; ++p)
-                {
-                    const GLsizei w = correctLinesize ? videoFrame.linesize[p] : widths[p];
-                    const GLsizei h = heights[p];
-                    if (p == 0)
-                        m_textureSize = QSize(w, h);
-                    if (hasPbo)
-                    {
-                        glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[p + 1]);
-                        glBufferData(GL_PIXEL_UNPACK_BUFFER, w * h, nullptr, GL_DYNAMIC_DRAW);
-                    }
-                    glBindTexture(GL_TEXTURE_2D, textures[p + 1]);
-                    glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, w, h, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, nullptr);
-                }
-
-                /* Prepare texture coordinates */
-                texCoordYCbCr[2] = texCoordYCbCr[6] = (videoFrame.linesize[0] == widths[0]) ? 1.0f : (widths[0] / (videoFrame.linesize[0] + 1.0f));
-
-                if (hqScaling)
-                    maybeSetMipmaps(widget()->devicePixelRatioF());
-            }
-            resetDone = true;
-            hasImage = false;
-        }
-
-        if (hwAccellnterface)
-        {
-            const HWAccelInterface::Field field = (HWAccelInterface::Field)Functions::getField(videoFrame, Deinterlace, HWAccelInterface::FullFrame, HWAccelInterface::TopField, HWAccelInterface::BottomField);
-            bool imageReady = false;
-            if (!hwAccelError)
-            {
-                const HWAccelInterface::MapResult res = hwAccellnterface->mapFrame(videoFrame, field);
-                if (res == HWAccelInterface::MapOk)
-                    imageReady = true;
-                else if (res == HWAccelInterface::MapError)
-                {
-                    QMPlay2Core.logError("OpenGL 2 :: " + hwAccellnterface->name() + " " + tr("texture copy error"));
-                    hwAccelError = true;
-                }
-            }
-            hwAccellnterface->unlock();
-            if (!imageReady && !hasImage)
-                return;
-            for (int p = 0; p < numPlanes; ++p)
-            {
-                glActiveTexture(GL_TEXTURE0 + p);
-                glBindTexture(target, textures[p + 1]);
-                if (m_useMipmaps)
-                    glGenerateMipmap(target);
-            }
-        }
-        else
-        {
-            /* Load textures */
-            for (qint32 p = 0; p < 3; ++p)
-            {
-                const quint8 *data = videoFrame.buffer[p].constData();
-                const GLsizei w = correctLinesize ? videoFrame.linesize[p] : widths[p];
-                const GLsizei h = heights[p];
-                if (hasPbo)
-                {
-                    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[p + 1]);
-                    quint8 *dst;
-                    if (glMapBufferRange)
-                        dst = (quint8 *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, w * h, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
-                    else
-                        dst = (quint8 *)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
-                    if (!dst)
-                        glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-                    else
-                    {
-                        if (correctLinesize)
-                            memcpy(dst, data, w * h);
-                        else for (int y = 0; y < h; ++y)
-                        {
-                            memcpy(dst, data, w);
-                            data += videoFrame.linesize[p];
-                            dst  += w;
-                        }
-                        glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
-                        data = nullptr;
-                    }
-                }
-                glActiveTexture(GL_TEXTURE0 + p);
-                glBindTexture(GL_TEXTURE_2D, textures[p + 1]);
-                if (hasPbo || correctLinesize)
-                    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, w, h, GL_LUMINANCE, GL_UNSIGNED_BYTE, data);
-                else for (int y = 0; y < h; ++y)
-                {
-                    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y, w, 1, GL_LUMINANCE, GL_UNSIGNED_BYTE, data);
-                    data += videoFrame.linesize[p];
-                }
-                if (m_useMipmaps)
-                    glGenerateMipmap(GL_TEXTURE_2D);
-            }
-            if (hasPbo)
-                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-        }
-
-        if (!hwAccellnterface || hwAccellnterface->isCopy())
-            videoFrame.clear();
-        hasImage = true;
-    }
-
-    if (!sphericalView)
-    {
-        deleteSphereVbo();
-        shaderProgramVideo->setAttributeArray(positionYCbCrLoc, verticesYCbCr[verticesIdx], 2);
-        shaderProgramVideo->setAttributeArray(texCoordYCbCrLoc, texCoordYCbCr, 2);
-    }
-    else
-    {
-        if (nIndices == 0)
-            loadSphere();
-
-        glBindBuffer(GL_ARRAY_BUFFER, sphereVbo[0]);
-        shaderProgramVideo->setAttributeBuffer(positionYCbCrLoc, GL_FLOAT, 0, 3);
-
-        glBindBuffer(GL_ARRAY_BUFFER, sphereVbo[1]);
-        shaderProgramVideo->setAttributeBuffer(texCoordYCbCrLoc, GL_FLOAT, 0, 2);
-
-        glBindBuffer(GL_ARRAY_BUFFER, 0);
-    }
-    shaderProgramVideo->enableAttributeArray(positionYCbCrLoc);
-    shaderProgramVideo->enableAttributeArray(texCoordYCbCrLoc);
-
-    shaderProgramVideo->bind();
-    if (doReset)
-    {
-        const float brightness = videoAdjustment.brightness / 100.0f;
-        const float contrast   = (videoAdjustment.contrast + 100) / 100.0f;
-        const float sharpness  = videoAdjustment.sharpness / 50.0f;
-        if (hwAccellnterface && numPlanes == 1)
-        {
-            hwAccellnterface->setVideAdjustment(videoAdjustment);
-            const bool hasBrightness = videoAdjustmentKeys.contains("Brightness");
-            const bool hasContrast   = videoAdjustmentKeys.contains("Contrast");
-            const bool hasSharpness  = videoAdjustmentKeys.contains("Sharpness");
-            shaderProgramVideo->setUniformValue
-            (
-                "uVideoAdj",
-                hasBrightness ? 0.0f : brightness,
-                hasContrast   ? 1.0f : contrast,
-                hasSharpness  ? 0.0f : sharpness
-            );
-        }
-        else
-        {
-            const auto lumaCoeff = QMPlay2PixelFormatConvert::getLumaCoeff(m_colorSpace);
-            const auto mat = Functions::getYUVtoRGBmatrix(lumaCoeff.cR, lumaCoeff.cG, lumaCoeff.cB, m_limited);
-            shaderProgramVideo->setUniformValue("uYUVtRGB", mat);
-            shaderProgramVideo->setUniformValue("uBL", m_limited ? 16.0f / 255.0f : 0.0f);
-
-            const float saturation = (videoAdjustment.saturation + 100) / 100.0f;
-            const float hue = videoAdjustment.hue / -31.831f;
-            shaderProgramVideo->setUniformValue("uVideoEq", brightness, contrast, saturation, hue);
-            shaderProgramVideo->setUniformValue("uSharpness", sharpness);
-        }
-        if (hqScaling)
-        {
-            const qreal dpr = widget()->devicePixelRatioF();
-            if (!resetDone)
-                maybeSetMipmaps(dpr);
-            const bool useBicubic = (W * dpr > m_textureSize.width() || H * dpr > m_textureSize.height());
-            shaderProgramVideo->setUniformValue("uBicubic", useBicubic ? 1 : 0);
-        }
-        shaderProgramVideo->setUniformValue("uTextureSize", m_textureSize);
-
-        doReset = !resetDone;
-        setMatrix = true;
-    }
-    if (setMatrix)
-    {
-        QMatrix4x4 matrix;
-        if (!sphericalView)
-        {
-            matrix.scale(W / (qreal)winSize.width(), H / (qreal)winSize.height());
-            if (!videoOffset.isNull())
-                matrix.translate(-videoOffset.x(), videoOffset.y());
-        }
-        else
-        {
-            const double z = qBound(-1.0, (zoom > 1.0 ? log10(zoom) : zoom - 1.0), 0.99);
-            matrix.perspective(68.0, (qreal)winSize.width() / (qreal)winSize.height(), 0.001, 2.0);
-            matrix.translate(0.0, 0.0, z);
-            matrix.rotate(rot.x(), 1.0, 0.0, 0.0);
-            matrix.rotate(rot.y(), 0.0, 0.0, 1.0);
-        }
-        shaderProgramVideo->setUniformValue("uMatrix", matrix);
-        setMatrix = false;
-    }
-    if (!sphericalView)
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-    else
-    {
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sphereVbo[2]);
-        glDrawElements(GL_TRIANGLE_STRIP, nIndices, GL_UNSIGNED_SHORT, nullptr);
-        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    }
-    shaderProgramVideo->release();
-
-    shaderProgramVideo->disableAttributeArray(texCoordYCbCrLoc);
-    shaderProgramVideo->disableAttributeArray(positionYCbCrLoc);
-
-    glActiveTexture(GL_TEXTURE3);
-
-    /* OSD */
-    osdMutex.lock();
-    if (!osdList.isEmpty())
-    {
-        glBindTexture(GL_TEXTURE_2D, textures[0]);
-
-        QRect bounds;
-        const qreal scaleW = (qreal)subsW / outW, scaleH = (qreal)subsH / outH;
-        bool mustRepaint = Functions::mustRepaintOSD(osdList, osd_ids, &scaleW, &scaleH, &bounds);
-        bool hasNewSize = false;
-        if (!mustRepaint)
-            mustRepaint = osdImg.size() != bounds.size();
-        if (mustRepaint)
-        {
-            if (osdImg.size() != bounds.size())
-            {
-                osdImg = QImage(bounds.size(), QImage::Format_ARGB32);
-                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, bounds.width(), bounds.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
-                hasNewSize = true;
-            }
-            osdImg.fill(0);
-            QPainter p(&osdImg);
-            p.translate(-bounds.topLeft());
-            Functions::paintOSD(false, osdList, scaleW, scaleH, p, &osd_ids);
-            const quint8 *data = osdImg.constBits();
-            if (hasPbo)
-            {
-                const GLsizeiptr dataSize = (osdImg.width() * osdImg.height()) << 2;
-                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[0]);
-                if (hasNewSize)
-                    glBufferData(GL_PIXEL_UNPACK_BUFFER, dataSize, nullptr, GL_DYNAMIC_DRAW);
-                quint8 *dst;
-                if (glMapBufferRange)
-                    dst = (quint8 *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, dataSize, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
-                else
-                    dst = (quint8 *)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
-                if (!dst)
-                    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-                else
-                {
-                    memcpy(dst, data, dataSize);
-                    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
-                    data = nullptr;
-                }
-            }
-            glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, bounds.width(), bounds.height(), GL_RGBA, GL_UNSIGNED_BYTE, data);
-            if (hasPbo && !data)
-                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-        }
-
-        const QSizeF winSizeSubs = winSize * widget()->devicePixelRatioF();
-        const float left   = (bounds.left() + subsX) * 2.0f / winSizeSubs.width() - osdOffset.x();
-        const float right  = (bounds.right() + subsX + 1) * 2.0f / winSizeSubs.width() - osdOffset.x();
-        const float top    = (bounds.top() + subsY) * 2.0f / winSizeSubs.height() - osdOffset.y();
-        const float bottom = (bounds.bottom() + subsY + 1) * 2.0f / winSizeSubs.height() - osdOffset.y();
-        const float verticesOSD[8] = {
-            left  - 1.0f, -bottom + 1.0f,
-            right - 1.0f, -bottom + 1.0f,
-            left  - 1.0f, -top    + 1.0f,
-            right - 1.0f, -top    + 1.0f,
-        };
-
-        shaderProgramOSD->setAttributeArray(positionOSDLoc, verticesOSD, 2);
-        shaderProgramOSD->setAttributeArray(texCoordOSDLoc, texCoordOSD, 2);
-        shaderProgramOSD->enableAttributeArray(positionOSDLoc);
-        shaderProgramOSD->enableAttributeArray(texCoordOSDLoc);
-
-        glEnable(GL_BLEND);
-        shaderProgramOSD->bind();
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-        shaderProgramOSD->release();
-        glDisable(GL_BLEND);
-
-        shaderProgramOSD->disableAttributeArray(texCoordOSDLoc);
-        shaderProgramOSD->disableAttributeArray(positionOSDLoc);
-    }
-    osdMutex.unlock();
-
-    glBindTexture(GL_TEXTURE_2D, 0);
+	const bool frameIsEmpty = videoFrame.isEmpty();
+
+	if (updateTimer.isActive())
+		updateTimer.stop();
+
+	if (frameIsEmpty && !hasImage)
+		return;
+
+	const QSize winSize = widget()->size();
+
+	bool resetDone = false;
+
+	if (!frameIsEmpty && hwAccellPossibleLock())
+	{
+		const GLsizei widths[3] = {
+			videoFrame.size.width,
+			videoFrame.size.chromaWidth(),
+			videoFrame.size.chromaWidth(),
+		};
+		const GLsizei heights[3] = {
+			videoFrame.size.height,
+			videoFrame.size.chromaHeight(),
+			videoFrame.size.chromaHeight()
+		};
+
+		if (doReset)
+		{
+			if (hwAccellnterface)
+			{
+				/* Release HWAccell resources */
+				hwAccellnterface->clear(false);
+
+				if (hwAccellnterface->canInitializeTextures())
+				{
+					if (numPlanes == 2)
+					{
+						//NV12
+						for (int p = 0; p < 2; ++p)
+						{
+							glBindTexture(target, textures[p + 1]);
+							glTexImage2D(target, 0, !p ? GL_R8 : GL_RG8, widths[p], heights[p], 0, !p ? GL_RED : GL_RG, GL_UNSIGNED_BYTE, nullptr);
+						}
+					}
+					else if (numPlanes == 1)
+					{
+						//RGB32
+						glBindTexture(target, textures[1]);
+						glTexImage2D(target, 0, GL_RGBA, widths[0], heights[0], 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
+					}
+				}
+
+				/* Prepare textures, register GL textures */
+				const bool hasHwAccelError = hwAccelError;
+				hwAccelError = !hwAccellnterface->init(&textures[1]);
+				if (hwAccelError && !hasHwAccelError)
+					QMPlay2Core.logError("OpenGL 2 :: " + tr("Can't init textures for") + " " + hwAccellnterface->name());
+
+				pixelStep = QVector2D(1.0f / widths[0], 1.0f / heights[0]);
+
+				/* Prepare texture coordinates */
+				texCoordYCbCr[2] = texCoordYCbCr[6] = 1.0f;
+			}
+			else
+			{
+				/* Check linesize */
+				const qint32 halfLinesize = (videoFrame.linesize[0] >> videoFrame.size.chromaShiftW);
+				correctLinesize =
+				(
+					(halfLinesize == videoFrame.linesize[1] && videoFrame.linesize[1] == videoFrame.linesize[2]) &&
+					(!sphericalView ? (videoFrame.linesize[1] == halfLinesize) : (videoFrame.linesize[0] == widths[0]))
+				);
+
+				/* Prepare textures */
+				for (qint32 p = 0; p < 3; ++p)
+				{
+					const GLsizei w = correctLinesize ? videoFrame.linesize[p] : widths[p];
+					const GLsizei h = heights[p];
+					if (p == 0)
+						pixelStep = QVector2D(1.0f / w, 1.0f / h);
+					if (hasPbo)
+					{
+						glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[p + 1]);
+						glBufferData(GL_PIXEL_UNPACK_BUFFER, w * h, nullptr, GL_DYNAMIC_DRAW);
+					}
+					glBindTexture(GL_TEXTURE_2D, textures[p + 1]);
+					glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, w, h, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, nullptr);
+				}
+
+				/* Prepare texture coordinates */
+				texCoordYCbCr[2] = texCoordYCbCr[6] = (videoFrame.linesize[0] == widths[0]) ? 1.0f : (widths[0] / (videoFrame.linesize[0] + 1.0f));
+			}
+			resetDone = true;
+			hasImage = false;
+		}
+
+		if (hwAccellnterface)
+		{
+			const HWAccelInterface::Field field = (HWAccelInterface::Field)Functions::getField(videoFrame, Deinterlace, HWAccelInterface::FullFrame, HWAccelInterface::TopField, HWAccelInterface::BottomField);
+			bool imageReady = false;
+			if (!hwAccelError)
+			{
+				const HWAccelInterface::CopyResult res = hwAccellnterface->copyFrame(videoFrame, field);
+				if (res == HWAccelInterface::CopyOk)
+					imageReady = true;
+				else if (res == HWAccelInterface::CopyError)
+				{
+					QMPlay2Core.logError("OpenGL 2 :: " + hwAccellnterface->name() + " " + tr("texture copy error"));
+					hwAccelError = true;
+				}
+			}
+			hwAccellnterface->unlock();
+			if (!imageReady && !hasImage)
+				return;
+			for (int p = 0; p < numPlanes; ++p)
+			{
+				glActiveTexture(GL_TEXTURE0 + p);
+				glBindTexture(target, textures[p + 1]);
+			}
+		}
+		else
+		{
+			/* Load textures */
+			for (qint32 p = 0; p < 3; ++p)
+			{
+				const quint8 *data = videoFrame.buffer[p].constData();
+				const GLsizei w = correctLinesize ? videoFrame.linesize[p] : widths[p];
+				const GLsizei h = heights[p];
+				if (hasPbo)
+				{
+					glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[p + 1]);
+					quint8 *dst;
+					if (glMapBufferRange)
+						dst = (quint8 *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, w * h, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
+					else
+						dst = (quint8 *)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+					if (!dst)
+						glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+					else
+					{
+						if (correctLinesize)
+							memcpy(dst, data, w * h);
+						else for (int y = 0; y < h; ++y)
+						{
+							memcpy(dst, data, w);
+							data += videoFrame.linesize[p];
+							dst  += w;
+						}
+						glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+						data = nullptr;
+					}
+				}
+				glActiveTexture(GL_TEXTURE0 + p);
+				glBindTexture(GL_TEXTURE_2D, textures[p + 1]);
+				if (hasPbo || correctLinesize)
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, w, h, GL_LUMINANCE, GL_UNSIGNED_BYTE, data);
+				else for (int y = 0; y < h; ++y)
+				{
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y, w, 1, GL_LUMINANCE, GL_UNSIGNED_BYTE, data);
+					data += videoFrame.linesize[p];
+				}
+			}
+			if (hasPbo)
+				glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+		}
+
+		videoFrame.clear();
+		hasImage = true;
+	}
+
+	if (!sphericalView)
+	{
+		deleteSphereVbo();
+		shaderProgramVideo->setAttributeArray(positionYCbCrLoc, verticesYCbCr[verticesIdx], 2);
+		shaderProgramVideo->setAttributeArray(texCoordYCbCrLoc, texCoordYCbCr, 2);
+	}
+	else
+	{
+		if (nIndices == 0)
+			loadSphere();
+
+		glBindBuffer(GL_ARRAY_BUFFER, sphereVbo[0]);
+		shaderProgramVideo->setAttributeBuffer(positionYCbCrLoc, GL_FLOAT, 0, 3);
+
+		glBindBuffer(GL_ARRAY_BUFFER, sphereVbo[1]);
+		shaderProgramVideo->setAttributeBuffer(texCoordYCbCrLoc, GL_FLOAT, 0, 2);
+
+		glBindBuffer(GL_ARRAY_BUFFER, 0);
+	}
+	shaderProgramVideo->enableAttributeArray(positionYCbCrLoc);
+	shaderProgramVideo->enableAttributeArray(texCoordYCbCrLoc);
+
+	shaderProgramVideo->bind();
+	if (doReset)
+	{
+		const float brightness = videoAdjustment.brightness / 100.0f;
+		const float contrast   = (videoAdjustment.contrast + 100) / 100.0f;
+		const float sharpness  = videoAdjustment.sharpness / 50.0f;
+		if (hwAccellnterface && numPlanes == 1)
+		{
+			hwAccellnterface->setVideAdjustment(videoAdjustment);
+			const bool hasBrightness = videoAdjustmentKeys.contains("Brightness");
+			const bool hasContrast   = videoAdjustmentKeys.contains("Contrast");
+			const bool hasSharpness  = videoAdjustmentKeys.contains("Sharpness");
+			shaderProgramVideo->setUniformValue
+			(
+				"uVideoAdj",
+				hasBrightness ? 0.0f : brightness,
+				hasContrast   ? 1.0f : contrast,
+				hasSharpness  ? 0.0f : sharpness
+			);
+		}
+		else
+		{
+			const float saturation = (videoAdjustment.saturation + 100) / 100.0f;
+			const float hue = videoAdjustment.hue / -31.831f;
+			shaderProgramVideo->setUniformValue("uVideoEq", brightness, contrast, saturation, hue);
+			shaderProgramVideo->setUniformValue("uSharpness", sharpness);
+		}
+		shaderProgramVideo->setUniformValue("uStep", pixelStep);
+
+		doReset = !resetDone;
+		setMatrix = true;
+	}
+	if (setMatrix)
+	{
+		QMatrix4x4 matrix;
+		if (!sphericalView)
+			matrix.scale(W / (qreal)winSize.width(), H / (qreal)winSize.height());
+		else
+		{
+			const double z = qBound(-1.0, (zoom > 1.0 ? log10(zoom) : zoom - 1.0), 0.99);
+			matrix.perspective(68.0, (qreal)winSize.width() / (qreal)winSize.height(), 0.001, 2.0);
+			matrix.translate(0.0, 0.0, z);
+			matrix.rotate(rot.x(), 1.0, 0.0, 0.0);
+			matrix.rotate(rot.y(), 0.0, 0.0, 1.0);
+		}
+		shaderProgramVideo->setUniformValue("uMatrix", matrix);
+		setMatrix = false;
+	}
+	if (!sphericalView)
+		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+	else
+	{
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sphereVbo[2]);
+		glDrawElements(GL_TRIANGLE_STRIP, nIndices, GL_UNSIGNED_SHORT, nullptr);
+		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+	}
+	shaderProgramVideo->release();
+
+	shaderProgramVideo->disableAttributeArray(texCoordYCbCrLoc);
+	shaderProgramVideo->disableAttributeArray(positionYCbCrLoc);
+
+	glActiveTexture(GL_TEXTURE3);
+
+	/* OSD */
+	osdMutex.lock();
+	if (!osdList.isEmpty())
+	{
+		glBindTexture(GL_TEXTURE_2D, textures[0]);
+
+		QRect bounds;
+		const qreal scaleW = (qreal)subsW / outW, scaleH = (qreal)subsH / outH;
+		bool mustRepaint = Functions::mustRepaintOSD(osdList, osd_ids, &scaleW, &scaleH, &bounds);
+		bool hasNewSize = false;
+		if (!mustRepaint)
+			mustRepaint = osdImg.size() != bounds.size();
+		if (mustRepaint)
+		{
+			if (osdImg.size() != bounds.size())
+			{
+				osdImg = QImage(bounds.size(), QImage::Format_ARGB32);
+				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, bounds.width(), bounds.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
+				hasNewSize = true;
+			}
+			osdImg.fill(0);
+			QPainter p(&osdImg);
+			p.translate(-bounds.topLeft());
+			Functions::paintOSD(false, osdList, scaleW, scaleH, p, &osd_ids);
+			const quint8 *data = osdImg.constBits();
+			if (hasPbo)
+			{
+				const GLsizeiptr dataSize = (osdImg.width() * osdImg.height()) << 2;
+				glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo[0]);
+				if (hasNewSize)
+					glBufferData(GL_PIXEL_UNPACK_BUFFER, dataSize, nullptr, GL_DYNAMIC_DRAW);
+				quint8 *dst;
+				if (glMapBufferRange)
+					dst = (quint8 *)glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, dataSize, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
+				else
+					dst = (quint8 *)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+				if (!dst)
+					glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+				else
+				{
+					memcpy(dst, data, dataSize);
+					glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+					data = nullptr;
+				}
+			}
+			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, bounds.width(), bounds.height(), GL_RGBA, GL_UNSIGNED_BYTE, data);
+			if (hasPbo && !data)
+				glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+		}
+
+		const QSizeF winSizeSubs = winSize * QMPlay2Core.getVideoDevicePixelRatio();
+		const float left   = (bounds.left() + subsX) * 2.0f / winSizeSubs.width();
+		const float right  = (bounds.right() + subsX + 1) * 2.0f / winSizeSubs.width();
+		const float top    = (bounds.top() + subsY) * 2.0f / winSizeSubs.height();
+		const float bottom = (bounds.bottom() + subsY + 1) * 2.0f / winSizeSubs.height();
+		const float verticesOSD[8] = {
+			left  - 1.0f, -bottom + 1.0f,
+			right - 1.0f, -bottom + 1.0f,
+			left  - 1.0f, -top    + 1.0f,
+			right - 1.0f, -top    + 1.0f,
+		};
+
+		shaderProgramOSD->setAttributeArray(positionOSDLoc, verticesOSD, 2);
+		shaderProgramOSD->setAttributeArray(texCoordOSDLoc, texCoordOSD, 2);
+		shaderProgramOSD->enableAttributeArray(positionOSDLoc);
+		shaderProgramOSD->enableAttributeArray(texCoordOSDLoc);
+
+		glEnable(GL_BLEND);
+		shaderProgramOSD->bind();
+		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+		shaderProgramOSD->release();
+		glDisable(GL_BLEND);
+
+		shaderProgramOSD->disableAttributeArray(texCoordOSDLoc);
+		shaderProgramOSD->disableAttributeArray(positionOSDLoc);
+	}
+	osdMutex.unlock();
+
+	glBindTexture(GL_TEXTURE_2D, 0);
 }
 
 void OpenGL2Common::contextAboutToBeDestroyed()
 {
-    if (hwAccellnterface && hwAccellnterface->lock())
-    {
-        hwAccellnterface->clear(true);
-        hwAccellnterface->unlock();
-    }
-    deleteSphereVbo();
-    if (hasPbo)
-        glDeleteBuffers(1 + (hwAccellnterface ? 0 : numPlanes), pbo);
-    glDeleteTextures(numPlanes + 1, textures);
+	if (hwAccellnterface && hwAccellnterface->lock())
+	{
+		hwAccellnterface->clear(true);
+		hwAccellnterface->unlock();
+	}
+	deleteSphereVbo();
+	if (hasPbo)
+		glDeleteBuffers(1 + (hwAccellnterface ? 0 : numPlanes), pbo);
+	glDeleteTextures(numPlanes + 1, textures);
 }
 
 void OpenGL2Common::testGLInternal()
 {
-    int glMajor = 0, glMinor = 0;
+	int glMajor = 0, glMinor = 0;
 #ifndef OPENGL_ES2
-    glGetIntegerv(GL_MAJOR_VERSION, &glMajor);
-    glGetIntegerv(GL_MINOR_VERSION, &glMinor);
+	glGetIntegerv(GL_MAJOR_VERSION, &glMajor);
+	glGetIntegerv(GL_MINOR_VERSION, &glMinor);
 #endif
-#ifndef Q_OS_MACOS //On macOS I have always OpenGL 2.1...
-    if (!glMajor)
-    {
-        const QString glVersionStr = (const char *)glGetString(GL_VERSION);
-        const int dotIdx = glVersionStr.indexOf('.');
-        if (dotIdx > 0)
-        {
-            const int vIdx = glVersionStr.lastIndexOf(' ', dotIdx);
-            if (sscanf(glVersionStr.mid(vIdx < 0 ? 0 : vIdx).toLatin1().constData(), "%d.%d", &glMajor, &glMinor) != 2)
-                glMajor = glMinor = 0;
-        }
-    }
-    if (glMajor)
-        glVer = glMajor * 10 + glMinor;
-    canUseHueSharpness = (glVer >= 30);
+#ifndef Q_OS_MAC //On macOS I have always OpenGL 2.1...
+	if (!glMajor)
+	{
+		const QString glVersionStr = (const char *)glGetString(GL_VERSION);
+		const int dotIdx = glVersionStr.indexOf('.');
+		if (dotIdx > 0)
+		{
+			const int vIdx = glVersionStr.lastIndexOf(' ', dotIdx);
+			if (sscanf(glVersionStr.mid(vIdx < 0 ? 0 : vIdx).toLatin1().data(), "%d.%d", &glMajor, &glMinor) != 2)
+				glMajor = glMinor = 0;
+		}
+	}
+	if (glMajor)
+		glVer = glMajor * 10 + glMinor;
+	canUseHueSharpness = (glVer >= 30);
 #endif
 
 #ifndef OPENGL_ES2
-    if (!initGLProc()) //No need to call it here for OpenGL|ES
-    {
-        isOK = false;
-    }
-    else if (!canCreateNonPowerOfTwoTextures || !supportsShaders || !glActiveTexture)
-    {
-        showOpenGLMissingFeaturesMessage();
-        isOK = false;
-    }
-    /* Reset variables */
-    supportsShaders = canCreateNonPowerOfTwoTextures = false;
-    glActiveTexture = nullptr;
+	initGLProc(); //No need to call it here for OpenGL|ES
+	if (!canCreateNonPowerOfTwoTextures || !supportsShaders || !glActiveTexture)
+	{
+		showOpenGLMissingFeaturesMessage();
+		isOK = false;
+	}
+	/* Reset variables */
+	supportsShaders = canCreateNonPowerOfTwoTextures = false;
+	glActiveTexture = nullptr;
 #endif
 
-    numPlanes = 3;
-    target = GL_TEXTURE_2D;
-    if (hwAccellnterface)
-    {
-        switch (hwAccellnterface->getFormat())
-        {
-            case HWAccelInterface::NV12:
-                numPlanes = 2;
-                break;
-            case HWAccelInterface::RGB32:
-                numPlanes = 1;
-                break;
-        }
-
-        if (hwAccellnterface->isTextureRectangle())
-        {
-            target = GL_TEXTURE_RECTANGLE_ARB;
-            if (numPlanes == 1)
-                isOK = false; // Not used and not supported
-            hqScaling = false; // Not yet supported
-        }
-
-        if (isOK)
-        {
-            quint32 textures[numPlanes];
-            memset(textures, 0, sizeof textures);
-            glGenTextures(numPlanes, textures);
-            if (hwAccellnterface->canInitializeTextures())
-            {
-                for (int p = 0; p < numPlanes; ++p)
-                {
-                    glBindTexture(target, textures[p]);
-                    if (numPlanes == 2)
-                        glTexImage2D(target, 0, !p ? GL_R8 : GL_RG8, 1, 1, 0, !p ? GL_RED : GL_RG, GL_UNSIGNED_BYTE, nullptr);
-                    else if (numPlanes == 1)
-                        glTexImage2D(target, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
-                }
-            }
-
-            if (!hwAccellnterface->lock())
-                isOK = false;
-            else
-            {
-                if (!hwAccellnterface->init(textures))
-                    isOK = false;
-                if (numPlanes == 1) //For RGB32 format, HWAccel should be able to adjust the video
-                {
-                    VideoAdjustment videoAdjustmentCap;
-                    hwAccellnterface->getVideAdjustmentCap(videoAdjustmentCap);
-                    if (videoAdjustmentCap.brightness)
-                        videoAdjustmentKeys += "Brightness";
-                    if (videoAdjustmentCap.contrast)
-                        videoAdjustmentKeys += "Contrast";
-                    if (videoAdjustmentCap.saturation)
-                        videoAdjustmentKeys += "Saturation";
-                    if (videoAdjustmentCap.hue)
-                        videoAdjustmentKeys += "Hue";
-                    if (videoAdjustmentCap.sharpness)
-                        videoAdjustmentKeys += "Sharpness";
-                }
-                hwAccellnterface->clear(true);
-                hwAccellnterface->unlock();
-            }
-
-            glDeleteTextures(numPlanes, textures);
-        }
-    }
-
-    QWidget *w = widget();
-    w->grabGesture(Qt::PinchGesture);
-    w->setMouseTracking(true);
+	numPlanes = 3;
+	target = GL_TEXTURE_2D;
+	if (hwAccellnterface)
+	{
+		switch (hwAccellnterface->getFormat())
+		{
+			case HWAccelInterface::NV12:
+				numPlanes = 2;
+				break;
+			case HWAccelInterface::RGB32:
+				numPlanes = 1;
+				break;
+		}
+
+		if (hwAccellnterface->isTextureRectangle())
+		{
+			target = GL_TEXTURE_RECTANGLE_ARB;
+			if (numPlanes == 1)
+				isOK = false; // Not used and not supported
+		}
+
+		if (isOK)
+		{
+			quint32 textures[numPlanes];
+			memset(textures, 0, sizeof textures);
+			glGenTextures(numPlanes, textures);
+			if (hwAccellnterface->canInitializeTextures())
+			{
+				for (int p = 0; p < numPlanes; ++p)
+				{
+					glBindTexture(target, textures[p]);
+					if (numPlanes == 2)
+						glTexImage2D(target, 0, !p ? GL_R8 : GL_RG8, 1, 1, 0, !p ? GL_RED : GL_RG, GL_UNSIGNED_BYTE, nullptr);
+					else if (numPlanes == 1)
+						glTexImage2D(target, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
+				}
+			}
+
+			if (!hwAccellnterface->lock())
+				isOK = false;
+			else
+			{
+				if (!hwAccellnterface->init(textures))
+					isOK = false;
+				if (numPlanes == 1) //For RGB32 format, HWAccel should be able to adjust the video
+				{
+					VideoAdjustment videoAdjustmentCap;
+					hwAccellnterface->getVideAdjustmentCap(videoAdjustmentCap);
+					if (videoAdjustmentCap.brightness)
+						videoAdjustmentKeys += "Brightness";
+					if (videoAdjustmentCap.contrast)
+						videoAdjustmentKeys += "Contrast";
+					if (videoAdjustmentCap.saturation)
+						videoAdjustmentKeys += "Saturation";
+					if (videoAdjustmentCap.hue)
+						videoAdjustmentKeys += "Hue";
+					if (videoAdjustmentCap.sharpness)
+						videoAdjustmentKeys += "Sharpness";
+				}
+				hwAccellnterface->clear(true);
+				hwAccellnterface->unlock();
+			}
+
+			glDeleteTextures(numPlanes, textures);
+		}
+	}
+
+	QWidget *w = widget();
+	w->grabGesture(Qt::PinchGesture);
+	w->setMouseTracking(true);
 #ifdef Q_OS_WIN
-    /*
-     * This property is read by QMPlay2 and it ensures that toolbar will be visible
-     * on fullscreen in Windows Vista and newer on nVidia and AMD drivers.
-    */
-    const bool canPreventFullScreen = (qstrcmp(w->metaObject()->className(), "QOpenGLWidget") != 0);
-    const QSysInfo::WinVersion winVer = QSysInfo::windowsVersion();
-    if (canPreventFullScreen && winVer >= QSysInfo::WV_6_0)
-    {
-        Qt::CheckState compositionEnabled;
-        if (!preventFullScreen)
-            compositionEnabled = Qt::PartiallyChecked;
-        else
-        {
-            compositionEnabled = Qt::Checked;
-            if (winVer <= QSysInfo::WV_6_1) //Windows 8 and 10 can't disable DWM composition
-            {
-                using DwmIsCompositionEnabledProc = HRESULT (WINAPI *)(BOOL *pfEnabled);
-                DwmIsCompositionEnabledProc DwmIsCompositionEnabled = (DwmIsCompositionEnabledProc)GetProcAddress(GetModuleHandleA("dwmapi.dll"), "DwmIsCompositionEnabled");
-                if (DwmIsCompositionEnabled)
-                {
-                    BOOL enabled = false;
-                    if (DwmIsCompositionEnabled(&enabled) == S_OK && !enabled)
-                        compositionEnabled = Qt::PartiallyChecked;
-                }
-            }
-        }
-        w->setProperty("preventFullScreen", (int)compositionEnabled);
-    }
+	/*
+	 * This property is read by QMPlay2 and it ensures that toolbar will be visible
+	 * on fullscreen in Windows Vista and newer on nVidia and AMD drivers.
+	*/
+	const bool canPreventFullScreen = (qstrcmp(w->metaObject()->className(), "QOpenGLWidget") != 0);
+	const QSysInfo::WinVersion winVer = QSysInfo::windowsVersion();
+	if (canPreventFullScreen && winVer >= QSysInfo::WV_6_0)
+	{
+		Qt::CheckState compositionEnabled;
+		if (!preventFullScreen)
+			compositionEnabled = Qt::PartiallyChecked;
+		else
+		{
+			compositionEnabled = Qt::Checked;
+			if (winVer <= QSysInfo::WV_6_1) //Windows 8 and 10 can't disable DWM composition
+			{
+				using DwmIsCompositionEnabledProc = HRESULT (WINAPI *)(BOOL *pfEnabled);
+				DwmIsCompositionEnabledProc DwmIsCompositionEnabled = (DwmIsCompositionEnabledProc)GetProcAddress(GetModuleHandleA("dwmapi.dll"), "DwmIsCompositionEnabled");
+				if (DwmIsCompositionEnabled)
+				{
+					BOOL enabled = false;
+					if (DwmIsCompositionEnabled(&enabled) == S_OK && !enabled)
+						compositionEnabled = Qt::PartiallyChecked;
+				}
+			}
+		}
+		w->setProperty("preventFullScreen", (int)compositionEnabled);
+	}
 #endif
 }
 
-bool OpenGL2Common::initGLProc()
+void OpenGL2Common::initGLProc()
 {
-    const auto context = QOpenGLContext::currentContext();
-    if (!context)
-        return false;
-
 #ifndef OPENGL_ES2
-    const char *glExtensions = (const char *)glGetString(GL_EXTENSIONS);
-    if (glExtensions)
-    {
-        supportsShaders = !!strstr(glExtensions, "GL_ARB_vertex_shader") && !!strstr(glExtensions, "GL_ARB_fragment_shader") && !!strstr(glExtensions, "GL_ARB_shader_objects");
-        canCreateNonPowerOfTwoTextures = !!strstr(glExtensions, "GL_ARB_texture_non_power_of_two");
-    }
-    glActiveTexture = (GLActiveTexture)context->getProcAddress("glActiveTexture");
-    glGenBuffers = (GLGenBuffers)context->getProcAddress("glGenBuffers");
-    glBindBuffer = (GLBindBuffer)context->getProcAddress("glBindBuffer");
-    glBufferData = (GLBufferData)context->getProcAddress("glBufferData");
-    glDeleteBuffers = (GLDeleteBuffers)context->getProcAddress("glDeleteBuffers");
-    if (hqScaling)
-        glGenerateMipmap = (GLGenerateMipmap)context->getProcAddress("glGenerateMipmap");
-    hasVbo = glGenBuffers && glBindBuffer && glBufferData && glDeleteBuffers;
+	const char *glExtensions = (const char *)glGetString(GL_EXTENSIONS);
+	if (glExtensions)
+	{
+		supportsShaders = !!strstr(glExtensions, "GL_ARB_vertex_shader") && !!strstr(glExtensions, "GL_ARB_fragment_shader") && !!strstr(glExtensions, "GL_ARB_shader_objects");
+		canCreateNonPowerOfTwoTextures = !!strstr(glExtensions, "GL_ARB_texture_non_power_of_two");
+	}
+	glActiveTexture = (GLActiveTexture)QOpenGLContext::currentContext()->getProcAddress("glActiveTexture");
+	glGenBuffers = (GLGenBuffers)QOpenGLContext::currentContext()->getProcAddress("glGenBuffers");
+	glBindBuffer = (GLBindBuffer)QOpenGLContext::currentContext()->getProcAddress("glBindBuffer");
+	glBufferData = (GLBufferData)QOpenGLContext::currentContext()->getProcAddress("glBufferData");
+	glDeleteBuffers = (GLDeleteBuffers)QOpenGLContext::currentContext()->getProcAddress("glDeleteBuffers");
+	hasVbo = glGenBuffers && glBindBuffer && glBufferData && glDeleteBuffers;
 #endif
-    if (allowPBO)
-    {
-        glMapBufferRange = (GLMapBufferRange)context->getProcAddress("glMapBufferRange");
-        glMapBuffer = (GLMapBuffer)context->getProcAddress("glMapBuffer");
-        glUnmapBuffer = (GLUnmapBuffer)context->getProcAddress("glUnmapBuffer");
-    }
-    hasPbo = hasVbo && (glMapBufferRange || glMapBuffer) && glUnmapBuffer;
-
-    return true;
+	if (allowPBO)
+	{
+		glMapBufferRange = (GLMapBufferRange)QOpenGLContext::currentContext()->getProcAddress("glMapBufferRange");
+		glMapBuffer = (GLMapBuffer)QOpenGLContext::currentContext()->getProcAddress("glMapBuffer");
+		glUnmapBuffer = (GLUnmapBuffer)QOpenGLContext::currentContext()->getProcAddress("glUnmapBuffer");
+	}
+	else
+	{
+		glMapBufferRange = nullptr;
+		glMapBuffer = nullptr;
+		glUnmapBuffer = nullptr;
+	}
+	hasPbo = hasVbo && (glMapBufferRange || glMapBuffer) && glUnmapBuffer;
 }
 #ifndef OPENGL_ES2
 void OpenGL2Common::showOpenGLMissingFeaturesMessage()
 {
-    fprintf
-    (
-        stderr,
-        "GL_ARB_texture_non_power_of_two : %s\n"
-        "Vertex & fragment shader: %s\n"
-        "glActiveTexture: %s\n",
-        canCreateNonPowerOfTwoTextures ? "yes" : "no",
-        supportsShaders ? "yes" : "no",
-        glActiveTexture ? "yes" : "no"
-    );
-    QMPlay2Core.logError("OpenGL 2 :: " + tr("Driver must support multitexturing, shaders and Non-Power-Of-Two texture size"), true, true);
+	fprintf
+	(
+		stderr,
+		"GL_ARB_texture_non_power_of_two : %s\n"
+		"Vertex & fragment shader: %s\n"
+		"glActiveTexture: %s\n",
+		canCreateNonPowerOfTwoTextures ? "yes" : "no",
+		supportsShaders ? "yes" : "no",
+		glActiveTexture ? "yes" : "no"
+	);
+	QMPlay2Core.logError("OpenGL 2 :: " + tr("Driver must support multitexturing, shaders and Non-Power-Of-Two texture size"), true, true);
 }
 #endif
 
 void OpenGL2Common::dispatchEvent(QEvent *e, QObject *p)
 {
-    switch (e->type())
-    {
-        case QEvent::MouseButtonPress:
-            if (sphericalView)
-                mousePress360((QMouseEvent *)e);
-            else
-                mousePress((QMouseEvent *)e);
-            break;
-        case QEvent::MouseButtonRelease:
-            if (sphericalView)
-                mouseRelease360((QMouseEvent *)e);
-            else
-                mouseRelease((QMouseEvent *)e);
-            break;
-        case QEvent::MouseMove:
-            if (sphericalView)
-                mouseMove360((QMouseEvent *)e);
-            else
-                mouseMove((QMouseEvent *)e);
-            break;
-        case QEvent::Resize:
-            newSize(((QResizeEvent *)e)->size());
-            break;
-        case QEvent::TouchBegin:
-        case QEvent::TouchUpdate:
-            canWrapMouse = false;
-            //Pass through
-        case QEvent::TouchEnd:
-        case QEvent::Gesture:
-            /* Pass gesture and touch event to the parent */
-            QCoreApplication::sendEvent(p, e);
-            break;
-        default:
-            break;
-    }
-}
-
-void OpenGL2Common::maybeSetMipmaps(qreal dpr)
-{
-    const bool lastUseMipmaps = m_useMipmaps;
-    m_useMipmaps = (W * dpr < m_textureSize.width() || H * dpr < m_textureSize.height());
-#ifndef OPENGL_ES2
-    if (m_useMipmaps && !glGenerateMipmap)
-    {
-        QMPlay2Core.logError("OpenGL 2 :: Mipmaps requested, but driver doesn't support it!", true, true);
-        m_useMipmaps = false;
-    }
-#endif
-    if (m_useMipmaps != lastUseMipmaps)
-    {
-        for (int p = 0; p < numPlanes; ++p)
-        {
-            glBindTexture(target, textures[p + 1]);
-            glTexParameteri(target, GL_TEXTURE_MIN_FILTER, m_useMipmaps ? GL_LINEAR_MIPMAP_LINEAR : GL_LINEAR);
-            if (m_useMipmaps)
-                glGenerateMipmap(target);
-        }
-    }
+	switch (e->type())
+	{
+		case QEvent::MouseButtonPress:
+			if (sphericalView)
+				mousePress360((QMouseEvent *)e);
+			break;
+		case QEvent::MouseButtonRelease:
+			if (sphericalView)
+				mouseRelease360((QMouseEvent *)e);
+			break;
+		case QEvent::MouseMove:
+			if (sphericalView)
+				mouseMove360((QMouseEvent *)e);
+			break;
+		case QEvent::Resize:
+			newSize(((QResizeEvent *)e)->size());
+			break;
+		case QEvent::TouchBegin:
+		case QEvent::TouchUpdate:
+			canWrapMouse = false;
+			//Pass through
+		case QEvent::TouchEnd:
+		case QEvent::Gesture:
+			/* Pass gesture and touch event to the parent */
+			QCoreApplication::sendEvent(p, e);
+			break;
+		default:
+			break;
+	}
 }
 
 inline bool OpenGL2Common::isRotate90() const
 {
-    return verticesIdx >= 4 && !sphericalView;
+	return verticesIdx >= 4 && !sphericalView;
 }
 
 inline bool OpenGL2Common::hwAccellPossibleLock()
 {
-    if (hwAccellnterface && !hwAccellnterface->lock())
-    {
-        QMPlay2Core.logError("OpenGL 2 :: " + hwAccellnterface->name() + " " + tr("error"));
-        hwAccelError = true;
-        return false;
-    }
-    return true;
+	if (hwAccellnterface && !hwAccellnterface->lock())
+	{
+		QMPlay2Core.logError("OpenGL 2 :: " + hwAccellnterface->name() + " " + tr("error"));
+		hwAccelError = true;
+		return false;
+	}
+	return true;
 }
 
-QByteArray OpenGL2Common::readShader(const QString &fileName, bool pure)
+QByteArray OpenGL2Common::readShader(const QString &fileName)
 {
-    QResource res(fileName);
-    QByteArray shader;
-    if (!pure)
-    {
+	QResource res(fileName);
+	QByteArray shader;
 #ifdef OPENGL_ES2
-        shader = "precision highp float;\n";
+	shader = "precision lowp float;\n";
 #endif
-        shader.append("#line 1\n");
-    }
-    shader.append((const char *)res.data(), res.size());
-    return shader;
-}
-
-void OpenGL2Common::mousePress(QMouseEvent *e)
-{
-    if (e->buttons() & Qt::LeftButton)
-    {
-        moveVideo = (e->modifiers() & Qt::ShiftModifier);
-        moveOSD = (e->modifiers() & Qt::ControlModifier);
-        if (moveVideo || moveOSD)
-        {
-            QWidget *w = widget();
-            w->setProperty("customCursor", (int)Qt::ArrowCursor);
-            w->setCursor(Qt::ClosedHandCursor);
-            mousePos = e->pos();
-        }
-    }
-}
-void OpenGL2Common::mouseMove(QMouseEvent *e)
-{
-    if ((moveVideo || moveOSD) && (e->buttons() & Qt::LeftButton))
-    {
-        const QPoint newMousePos = e->pos();
-        const QPointF mouseDiff = mousePos - newMousePos;
-
-        if (moveVideo)
-            videoOffset += QPointF(mouseDiff.x() * 2.0 / W, mouseDiff.y() * 2.0 / H);
-        if (moveOSD)
-        {
-            QWidget *w = widget();
-            osdOffset += QPointF(mouseDiff.x() * 2.0 / w->width(), mouseDiff.y() * 2.0 / w->height());
-        }
-
-        mousePos = newMousePos;
-
-        setMatrix = true;
-        updateGL(true);
-    }
-}
-void OpenGL2Common::mouseRelease(QMouseEvent *e)
-{
-    if ((moveVideo || moveOSD) && e->button() == Qt::LeftButton)
-    {
-        QWidget *w = widget();
-        w->unsetCursor();
-        w->setProperty("customCursor", QVariant());
-        moveVideo = moveOSD = false;
-    }
+	shader.append("#line 1\n");
+	shader.append((const char *)res.data(), res.size());
+	return shader;
 }
 
 /* 360 */
 
 void OpenGL2Common::mousePress360(QMouseEvent *e)
 {
-    if (e->buttons() & Qt::LeftButton)
-    {
-        widget()->setCursor(Qt::ClosedHandCursor);
-        mouseTime = Functions::gettime();
-        buttonPressed = true;
-        rotAnimation.stop();
-        mousePos = e->pos();
-    }
+	if (e->buttons() & Qt::LeftButton)
+	{
+		widget()->setCursor(Qt::ClosedHandCursor);
+		mouseTime = Functions::gettime();
+		buttonPressed = true;
+		rotAnimation.stop();
+		mousePos = e->pos();
+	}
 }
 void OpenGL2Common::mouseMove360(QMouseEvent *e)
 {
-    if (mouseWrapped)
-        mouseWrapped = false;
-    else if (buttonPressed && (e->buttons() & Qt::LeftButton))
-    {
-        const QPoint newMousePos = e->pos();
-        const QPointF mouseDiff = QPointF(mousePos - newMousePos) / 10.0;
-
-        rot.setX(qBound<qreal>(0.0, (rot.rx() += mouseDiff.y()), 180.0));
-        rot.ry() -= mouseDiff.x();
-
-        const double currTime = Functions::gettime();
-        const double mouseTimeDiff = qMax(currTime - mouseTime, 0.001);
-        const QPointF movPerSec(mouseDiff.y() / mouseTimeDiff / 5.0, -mouseDiff.x() / mouseTimeDiff / 5.0);
-        if (rotAnimation.state() != QAbstractAnimation::Stopped)
-            rotAnimation.stop();
-        rotAnimation.setEndValue(rot + movPerSec);
-        mouseTime = currTime;
-
-        mousePos = newMousePos;
-        if (e->source() == Qt::MouseEventNotSynthesized)
-        {
-            if (canWrapMouse)
-                mouseWrapped = Functions::wrapMouse(widget(), mousePos, 1);
-            else
-                canWrapMouse = true;
-        }
-
-        setMatrix = true;
-        updateGL(true);
-    }
+	if (mouseWrapped)
+		mouseWrapped = false;
+	else if (buttonPressed && (e->buttons() & Qt::LeftButton))
+	{
+		const QPoint newMousePos = e->pos();
+		const QPointF mouseDiff = QPointF(mousePos - newMousePos) / 10.0;
+
+		rot.setX(qBound<qreal>(0.0, (rot.rx() += mouseDiff.y()), 180.0));
+		rot.ry() -= mouseDiff.x();
+
+		const double currTime = Functions::gettime();
+		const double mouseTimeDiff = qMax(currTime - mouseTime, 0.001);
+		const QPointF movPerSec(mouseDiff.y() / mouseTimeDiff / 5.0, -mouseDiff.x() / mouseTimeDiff / 5.0);
+		if (rotAnimation.state() != QAbstractAnimation::Stopped)
+			rotAnimation.stop();
+		rotAnimation.setEndValue(rot + movPerSec);
+		mouseTime = currTime;
+
+		mousePos = newMousePos;
+#if QT_VERSION >= 0x050300
+		if (e->source() == Qt::MouseEventNotSynthesized)
+#endif
+		{
+			if (canWrapMouse)
+				mouseWrapped = Functions::wrapMouse(widget(), mousePos, 1);
+			else
+				canWrapMouse = true;
+		}
+
+		setMatrix = true;
+		updateGL(true);
+	}
 }
 void OpenGL2Common::mouseRelease360(QMouseEvent *e)
 {
-    if (buttonPressed && e->button() == Qt::LeftButton)
-    {
-        if ((Functions::gettime() - mouseTime) >= 0.075)
-            rotAnimation.stop();
-        else
-        {
-            rotAnimation.setStartValue(rot);
-            rotAnimation.start();
-        }
-        widget()->setCursor(Qt::OpenHandCursor);
-        buttonPressed = false;
-    }
+	if (buttonPressed && e->button() == Qt::LeftButton)
+	{
+		if ((Functions::gettime() - mouseTime) >= 0.075)
+			rotAnimation.stop();
+		else
+		{
+			rotAnimation.setStartValue(rot);
+			rotAnimation.start();
+		}
+		widget()->setCursor(Qt::OpenHandCursor);
+		buttonPressed = false;
+	}
 }
 inline void OpenGL2Common::resetSphereVbo()
 {
-    memset(sphereVbo, 0, sizeof sphereVbo);
-    nIndices = 0;
+	memset(sphereVbo, 0, sizeof sphereVbo);
+	nIndices = 0;
 }
 inline void OpenGL2Common::deleteSphereVbo()
 {
-    if (nIndices > 0)
-    {
-        glDeleteBuffers(3, sphereVbo);
-        resetSphereVbo();
-    }
+	if (nIndices > 0)
+	{
+		glDeleteBuffers(3, sphereVbo);
+		resetSphereVbo();
+	}
 }
 void OpenGL2Common::loadSphere()
 {
-    const quint32 slices = 50;
-    const quint32 stacks = 50;
-    const GLenum targets[3] = {
-        GL_ARRAY_BUFFER,
-        GL_ARRAY_BUFFER,
-        GL_ELEMENT_ARRAY_BUFFER
-    };
-    void *pointers[3];
-    quint32 sizes[3];
-    nIndices = Sphere::getSizes(slices, stacks, sizes[0], sizes[1], sizes[2]);
-    glGenBuffers(3, sphereVbo);
-    for (qint32 i = 0; i < 3; ++i)
-        pointers[i] = malloc(sizes[i]);
-    Sphere::generate(1.0f, slices, stacks, (float *)pointers[0], (float *)pointers[1], (quint16 *)pointers[2]);
-    for (qint32 i = 0; i < 3; ++i)
-    {
-        glBindBuffer(targets[i], sphereVbo[i]);
-        glBufferData(targets[i], sizes[i], pointers[i], GL_STATIC_DRAW);
-        free(pointers[i]);
-    }
+	const quint32 slices = 50;
+	const quint32 stacks = 50;
+	const GLenum targets[3] = {
+		GL_ARRAY_BUFFER,
+		GL_ARRAY_BUFFER,
+		GL_ELEMENT_ARRAY_BUFFER
+	};
+	void *pointers[3];
+	quint32 sizes[3];
+	nIndices = Sphere::getSizes(slices, stacks, sizes[0], sizes[1], sizes[2]);
+	glGenBuffers(3, sphereVbo);
+	for (qint32 i = 0; i < 3; ++i)
+		pointers[i] = malloc(sizes[i]);
+	Sphere::generate(1.0f, slices, stacks, (float *)pointers[0], (float *)pointers[1], (quint16 *)pointers[2]);
+	for (qint32 i = 0; i < 3; ++i)
+	{
+		glBindBuffer(targets[i], sphereVbo[i]);
+		glBufferData(targets[i], sizes[i], pointers[i], GL_STATIC_DRAW);
+		free(pointers[i]);
+	}
 }
diff --git a/src/modules/OpenGL2/OpenGL2Common.hpp b/src/modules/OpenGL2/OpenGL2Common.hpp
index 60604799..d8f81dbe 100644
--- a/src/modules/OpenGL2/OpenGL2Common.hpp
+++ b/src/modules/OpenGL2/OpenGL2Common.hpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
@@ -21,7 +21,12 @@
 #include <VideoFrame.hpp>
 #include <VideoAdjustment.hpp>
 
-#include <QOpenGLShaderProgram>
+#ifdef OPENGL_NEW_API
+	#include <QOpenGLShaderProgram>
+#else
+	#include <QGLShaderProgram>
+	#define QOpenGLShaderProgram QGLShaderProgram
+#endif
 
 #include <QVariantAnimation>
 #include <QCoreApplication>
@@ -29,12 +34,12 @@
 #include <QMutex>
 #include <QTimer>
 
-#if !defined OPENGL_ES2 && !defined Q_OS_MACOS
-    #include <GL/glext.h>
+#if !defined OPENGL_ES2 && !defined Q_OS_MAC
+	#include <GL/glext.h>
 #endif
 
 #if defined OPENGL_ES2 && !defined APIENTRY
-    #define APIENTRY
+	#define APIENTRY
 #endif
 
 class HWAccelInterface;
@@ -42,146 +47,134 @@ class OpenGL2Common;
 class QMPlay2OSD;
 class QMouseEvent;
 
-class RotAnimation final : public QVariantAnimation
+class RotAnimation : public QVariantAnimation
 {
 public:
-    inline RotAnimation(OpenGL2Common &glCommon) :
-        glCommon(glCommon)
-    {}
+	inline RotAnimation(OpenGL2Common &glCommon) :
+		glCommon(glCommon)
+	{}
 private:
-    void updateCurrentValue(const QVariant &value) override;
+	void updateCurrentValue(const QVariant &value) override final;
 
-    OpenGL2Common &glCommon;
+	OpenGL2Common &glCommon;
 };
 
 /**/
 
 class OpenGL2Common
 {
-    Q_DECLARE_TR_FUNCTIONS(OpenGL2Common)
+	Q_DECLARE_TR_FUNCTIONS(OpenGL2Common)
 #ifndef OPENGL_ES2
-    using GLActiveTexture  = void  (APIENTRY *)(GLenum);
-    using GLGenBuffers     = void  (APIENTRY *)(GLsizei, GLuint *);
-    using GLBindBuffer     = void  (APIENTRY *)(GLenum, GLuint);
-    using GLBufferData     = void  (APIENTRY *)(GLenum, GLsizeiptr, const void *, GLenum);
-    using GLDeleteBuffers  = void  (APIENTRY *)(GLsizei, const GLuint *);
-    using GLGenerateMipmap = void  (APIENTRY *)(GLenum);
+	using GLActiveTexture  = void  (APIENTRY *)(GLenum);
+	using GLGenBuffers     = void  (APIENTRY *)(GLsizei, GLuint *);
+	using GLBindBuffer     = void  (APIENTRY *)(GLenum, GLuint);
+	using GLBufferData     = void  (APIENTRY *)(GLenum, GLsizeiptr, const void *, GLenum);
+	using GLDeleteBuffers  = void  (APIENTRY *)(GLsizei, const GLuint *);
 #endif
-    using GLMapBufferRange = void *(APIENTRY *)(GLenum, GLintptr, GLsizeiptr, GLbitfield);
-    using GLMapBuffer      = void *(APIENTRY *)(GLenum, GLbitfield);
-    using GLUnmapBuffer    = GLboolean(APIENTRY *)(GLenum);
+	using GLMapBufferRange = void *(APIENTRY *)(GLenum, GLintptr, GLsizeiptr, GLbitfield);
+	using GLMapBuffer      = void *(APIENTRY *)(GLenum, GLbitfield);
+	using GLUnmapBuffer    = GLboolean(APIENTRY *)(GLenum);
 public:
-    OpenGL2Common();
-    virtual ~OpenGL2Common();
+	OpenGL2Common();
+	virtual ~OpenGL2Common();
 
-    virtual void deleteMe();
+	virtual void deleteMe();
 
-    virtual QWidget *widget() = 0;
+	virtual QWidget *widget() = 0;
 
-    bool testGL();
-    virtual bool setVSync(bool enable) = 0;
-    virtual void updateGL(bool requestDelayed) = 0;
+	virtual bool testGL() = 0;
+	virtual bool setVSync(bool enable) = 0;
+	virtual void updateGL(bool requestDelayed) = 0;
 
-    void newSize(const QSize &size = QSize());
-    void clearImg();
+	void newSize(const QSize &size = QSize());
+	void clearImg();
 
-    void setSpherical(bool spherical);
+	void setSpherical(bool spherical);
 protected:
-    void initializeGL();
-    void paintGL();
+	void initializeGL();
+	void paintGL();
 
-    void contextAboutToBeDestroyed();
+	void contextAboutToBeDestroyed();
 
-    void testGLInternal();
+	void testGLInternal();
 
-    bool initGLProc();
+	void initGLProc();
 #ifndef OPENGL_ES2
-    void showOpenGLMissingFeaturesMessage();
-
-    bool supportsShaders, canCreateNonPowerOfTwoTextures;
-    GLActiveTexture glActiveTexture;
-    GLGenBuffers glGenBuffers;
-    GLBindBuffer glBindBuffer;
-    GLBufferData glBufferData;
-    GLDeleteBuffers glDeleteBuffers;
-    GLGenerateMipmap glGenerateMipmap = nullptr;
+	void showOpenGLMissingFeaturesMessage();
+
+	bool supportsShaders, canCreateNonPowerOfTwoTextures;
+	GLActiveTexture glActiveTexture;
+	GLGenBuffers glGenBuffers;
+	GLBindBuffer glBindBuffer;
+	GLBufferData glBufferData;
+	GLDeleteBuffers glDeleteBuffers;
 #endif
-    GLMapBufferRange glMapBufferRange = nullptr;
-    GLMapBuffer glMapBuffer = nullptr;
-    GLUnmapBuffer glUnmapBuffer = nullptr;
+	GLMapBufferRange glMapBufferRange;
+	GLMapBuffer glMapBuffer;
+	GLUnmapBuffer glUnmapBuffer;
 
-    bool vSync;
+#ifdef VSYNC_SETTINGS
+	bool vSync;
+#endif
 
-    void dispatchEvent(QEvent *e, QObject *p);
+	void dispatchEvent(QEvent *e, QObject *p);
 private:
-    void maybeSetMipmaps(qreal dpr);
-
-    inline bool isRotate90() const;
+	inline bool isRotate90() const;
 
-    inline bool hwAccellPossibleLock();
+	inline bool hwAccellPossibleLock();
 
-    QByteArray readShader(const QString &fileName, bool pure = false);
+	QByteArray readShader(const QString &fileName);
 
-    void mousePress(QMouseEvent *e);
-    void mouseMove(QMouseEvent *e);
-    void mouseRelease(QMouseEvent *e);
-
-    /* Spherical view */
-    void mousePress360(QMouseEvent *e);
-    void mouseMove360(QMouseEvent *e);
-    void mouseRelease360(QMouseEvent *e);
-    inline void resetSphereVbo();
-    inline void deleteSphereVbo();
-    void loadSphere();
+	/* Spherical view */
+	void mousePress360(QMouseEvent *e);
+	void mouseMove360(QMouseEvent *e);
+	void mouseRelease360(QMouseEvent *e);
+	inline void resetSphereVbo();
+	inline void deleteSphereVbo();
+	void loadSphere();
 public:
-    HWAccelInterface *hwAccellnterface;
-    QStringList videoAdjustmentKeys;
-    VideoFrame videoFrame;
-
-    bool m_limited = false;
-    QMPlay2ColorSpace m_colorSpace = QMPlay2ColorSpace::Unknown;
+	HWAccelInterface *hwAccellnterface;
+	QStringList videoAdjustmentKeys;
+	VideoFrame videoFrame;
 
-    QOpenGLShaderProgram *shaderProgramVideo, *shaderProgramOSD;
+	QOpenGLShaderProgram *shaderProgramVideo, *shaderProgramOSD;
 
-    qint32 texCoordYCbCrLoc, positionYCbCrLoc, texCoordOSDLoc, positionOSDLoc;
-    VideoAdjustment videoAdjustment;
-    float texCoordYCbCr[8];
-    quint32 textures[4];
-    QSize m_textureSize;
-    qint32 numPlanes;
-    quint32 target;
-    int Deinterlace;
+	qint32 texCoordYCbCrLoc, positionYCbCrLoc, texCoordOSDLoc, positionOSDLoc;
+	VideoAdjustment videoAdjustment;
+	float texCoordYCbCr[8];
+	QVector2D pixelStep;
+	quint32 textures[4];
+	qint32 numPlanes;
+	quint32 target;
+	int Deinterlace;
 
-    quint32 pbo[4];
-    bool allowPBO, hasPbo, hqScaling = false;
+	quint32 pbo[4];
+	bool allowPBO, hasPbo;
 
 #ifdef Q_OS_WIN
-    bool preventFullScreen;
+	bool preventFullScreen;
 #endif
 
-    bool isPaused, isOK, hwAccelError, hasImage, doReset, setMatrix, correctLinesize, canUseHueSharpness, m_useMipmaps = false;
-    int subsX, subsY, W, H, subsW, subsH, outW, outH, verticesIdx;
-    int glVer;
-
-    double aspectRatio, zoom;
+	bool isPaused, isOK, hwAccelError, hasImage, doReset, setMatrix, correctLinesize, canUseHueSharpness;
+	int subsX, subsY, W, H, subsW, subsH, outW, outH, verticesIdx;
+	int glVer;
 
-    bool moveVideo = false, moveOSD = false;
-    QPointF videoOffset, osdOffset;
+	double aspectRatio, zoom;
 
-    QList<const QMPlay2OSD *> osdList;
-    QMutex osdMutex;
+	QList<const QMPlay2OSD *> osdList;
+	QMutex osdMutex;
 
-    QVector<quint64> osd_ids;
-    QImage osdImg;
+	QVector<quint64> osd_ids;
+	QImage osdImg;
 
-    QTimer updateTimer;
+	QTimer updateTimer;
 
-    /* Spherical view */
-    bool sphericalView, buttonPressed, hasVbo, mouseWrapped, canWrapMouse;
-    RotAnimation rotAnimation;
-    quint32 sphereVbo[3];
-    quint32 nIndices;
-    double mouseTime;
-    QPoint mousePos; // also for moving video/subtitles
-    QPointF rot;
+	/* Spherical view */
+	bool sphericalView, buttonPressed, hasVbo, mouseWrapped, canWrapMouse;
+	RotAnimation rotAnimation;
+	quint32 sphereVbo[3];
+	quint32 nIndices;
+	double mouseTime;
+	QPoint mousePos;
+	QPointF rot;
 };
diff --git a/src/modules/OpenGL2/OpenGL2CommonQt5.cpp b/src/modules/OpenGL2/OpenGL2CommonQt5.cpp
new file mode 100644
index 00000000..3cc444f0
--- /dev/null
+++ b/src/modules/OpenGL2/OpenGL2CommonQt5.cpp
@@ -0,0 +1,35 @@
+/*
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <OpenGL2CommonQt5.hpp>
+
+#include <QOffscreenSurface>
+#include <QOpenGLContext>
+
+bool OpenGL2CommonQt5::testGL()
+{
+	QOpenGLContext glCtx;
+	if ((isOK = glCtx.create()))
+	{
+		QOffscreenSurface offscreenSurface;
+		offscreenSurface.create();
+		if ((isOK = glCtx.makeCurrent(&offscreenSurface)))
+			testGLInternal();
+	}
+	return isOK;
+}
diff --git a/src/modules/OpenGL2/OpenGL2CommonQt5.hpp b/src/modules/OpenGL2/OpenGL2CommonQt5.hpp
new file mode 100644
index 00000000..bd370ec7
--- /dev/null
+++ b/src/modules/OpenGL2/OpenGL2CommonQt5.hpp
@@ -0,0 +1,27 @@
+/*
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+#include <OpenGL2Common.hpp>
+
+class OpenGL2CommonQt5 : public OpenGL2Common
+{
+protected:
+	bool testGL() override final;
+};
diff --git a/src/modules/OpenGL2/OpenGL2OldWidget.cpp b/src/modules/OpenGL2/OpenGL2OldWidget.cpp
new file mode 100644
index 00000000..ae819060
--- /dev/null
+++ b/src/modules/OpenGL2/OpenGL2OldWidget.cpp
@@ -0,0 +1,100 @@
+/*
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "OpenGL2OldWidget.hpp"
+
+#include <QMPlay2Core.hpp>
+
+OpenGL2OldWidget::OpenGL2OldWidget()
+{
+	connect(&updateTimer, SIGNAL(timeout()), this, SLOT(updateGL())); //updateGL() from the base class
+}
+OpenGL2OldWidget::~OpenGL2OldWidget()
+{
+	makeCurrent();
+}
+
+QWidget *OpenGL2OldWidget::widget()
+{
+	return this;
+}
+
+bool OpenGL2OldWidget::testGL()
+{
+	makeCurrent();
+	if ((isOK = isValid()))
+		testGLInternal();
+	doneCurrent();
+	return isOK;
+}
+bool OpenGL2OldWidget::setVSync(bool enable)
+{
+#ifdef VSYNC_SETTINGS
+	bool doDoneCurrent = false;
+	if (QGLContext::currentContext() != context())
+	{
+		makeCurrent();
+		doDoneCurrent = true;
+	}
+	using SwapInterval = int (APIENTRY *)(int); //BOOL is just normal int in Windows, APIENTRY declares nothing on non-Windows platforms
+	SwapInterval swapInterval = NULL;
+#ifdef Q_OS_WIN
+	swapInterval = (SwapInterval)context()->getProcAddress("wglSwapIntervalEXT");
+#else
+	swapInterval = (SwapInterval)context()->getProcAddress("glXSwapIntervalMESA");
+	if (!swapInterval)
+		swapInterval = (SwapInterval)context()->getProcAddress("glXSwapIntervalSGI");
+#endif
+	if (swapInterval)
+		swapInterval(enable);
+	if (doDoneCurrent)
+		doneCurrent();
+	vSync = enable;
+#else
+	Q_UNUSED(enable)
+#endif
+	return true;
+}
+void OpenGL2OldWidget::updateGL(bool requestDelayed)
+{
+	if (requestDelayed)
+		QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest), Qt::LowEventPriority);
+	else
+		QGLWidget::updateGL();
+}
+
+void OpenGL2OldWidget::initializeGL()
+{
+	OpenGL2Common::initializeGL();
+}
+void OpenGL2OldWidget::paintGL()
+{
+	glClear(GL_COLOR_BUFFER_BIT);
+	OpenGL2Common::paintGL();
+}
+
+void OpenGL2OldWidget::resizeGL(int w, int h)
+{
+	glViewport(0, 0, w, h);
+}
+
+bool OpenGL2OldWidget::event(QEvent *e)
+{
+	dispatchEvent(e, parent());
+	return QGLWidget::event(e);
+}
diff --git a/src/modules/OpenGL2/OpenGL2OldWidget.hpp b/src/modules/OpenGL2/OpenGL2OldWidget.hpp
new file mode 100644
index 00000000..115597ca
--- /dev/null
+++ b/src/modules/OpenGL2/OpenGL2OldWidget.hpp
@@ -0,0 +1,47 @@
+/*
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef OPENGL2OLDWIDGET_HPP
+#define OPENGL2OLDWIDGET_HPP
+
+#include <OpenGL2Common.hpp>
+
+#include <QGLWidget>
+
+class OpenGL2OldWidget : public QGLWidget, public OpenGL2Common
+{
+	Q_OBJECT
+public:
+	OpenGL2OldWidget();
+        ~OpenGL2OldWidget() final;
+
+	QWidget *widget() override final;
+
+	bool testGL() override final;
+	bool setVSync(bool enable) override final;
+	void updateGL(bool requestDelayed) override final;
+
+	void initializeGL() override final;
+	void paintGL() override final;
+private:
+	void resizeGL(int w, int h) override final;
+
+	bool event(QEvent *e) override final;
+};
+
+#endif // OPENGL2OLDWIDGET_HPP
diff --git a/src/modules/OpenGL2/OpenGL2Widget.cpp b/src/modules/OpenGL2/OpenGL2Widget.cpp
index 11b26fcf..eec2b741 100644
--- a/src/modules/OpenGL2/OpenGL2Widget.cpp
+++ b/src/modules/OpenGL2/OpenGL2Widget.cpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "OpenGL2Widget.hpp"
@@ -22,58 +22,58 @@
 
 OpenGL2Widget::OpenGL2Widget()
 {
-    connect(&updateTimer, SIGNAL(timeout()), this, SLOT(update()));
+	connect(&updateTimer, SIGNAL(timeout()), this, SLOT(update()));
 }
 OpenGL2Widget::~OpenGL2Widget()
 {
-    makeCurrent();
+	makeCurrent();
 }
 
 QWidget *OpenGL2Widget::widget()
 {
-    return this;
+	return this;
 }
 
 bool OpenGL2Widget::setVSync(bool enable)
 {
-    QSurfaceFormat fmt = format();
-    vSync = enable;
-    if (!isValid())
-    {
-        fmt.setSwapBehavior(QSurfaceFormat::DoubleBuffer); //Probably it doesn't work
-        fmt.setSwapInterval(enable); //Does it work on QOpenGLWidget?
-        setFormat(fmt);
-        return true;
-    }
-    return (fmt.swapInterval() == enable);
+	QSurfaceFormat fmt = format();
+	vSync = enable;
+	if (!isValid())
+	{
+		fmt.setSwapBehavior(QSurfaceFormat::DoubleBuffer); //Probably it doesn't work
+		fmt.setSwapInterval(enable); //Does it work on QOpenGLWidget?
+		setFormat(fmt);
+		return true;
+	}
+	return (fmt.swapInterval() == enable);
 }
 void OpenGL2Widget::updateGL(bool requestDelayed)
 {
-    if (requestDelayed)
-        QMetaObject::invokeMethod(this, "update", Qt::QueuedConnection);
-    else
-        update();
+	if (requestDelayed)
+		QMetaObject::invokeMethod(this, "update", Qt::QueuedConnection);
+	else
+		update();
 }
 
 void OpenGL2Widget::initializeGL()
 {
-    connect(context(), SIGNAL(aboutToBeDestroyed()), this, SLOT(aboutToBeDestroyed()), Qt::DirectConnection);
-    OpenGL2Common::initializeGL();
+	connect(context(), SIGNAL(aboutToBeDestroyed()), this, SLOT(aboutToBeDestroyed()), Qt::DirectConnection);
+	OpenGL2Common::initializeGL();
 }
 void OpenGL2Widget::paintGL()
 {
-    OpenGL2Common::paintGL();
+	OpenGL2Common::paintGL();
 }
 
 void OpenGL2Widget::aboutToBeDestroyed()
 {
-    makeCurrent();
-    contextAboutToBeDestroyed();
-    doneCurrent();
+	makeCurrent();
+	contextAboutToBeDestroyed();
+	doneCurrent();
 }
 
 bool OpenGL2Widget::event(QEvent *e)
 {
-    dispatchEvent(e, parent());
-    return QOpenGLWidget::event(e);
+	dispatchEvent(e, parent());
+	return QOpenGLWidget::event(e);
 }
diff --git a/src/modules/OpenGL2/OpenGL2Widget.hpp b/src/modules/OpenGL2/OpenGL2Widget.hpp
index 3e8bc14e..731bffb9 100644
--- a/src/modules/OpenGL2/OpenGL2Widget.hpp
+++ b/src/modules/OpenGL2/OpenGL2Widget.hpp
@@ -1,44 +1,44 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
 
-#include <OpenGL2Common.hpp>
+#include <OpenGL2CommonQt5.hpp>
 
 #include <QSurfaceFormat>
 #include <QOpenGLWidget>
 
-class OpenGL2Widget final : public QOpenGLWidget, public OpenGL2Common
+class OpenGL2Widget : public QOpenGLWidget, public OpenGL2CommonQt5
 {
-    Q_OBJECT
+	Q_OBJECT
 public:
-    OpenGL2Widget();
-    ~OpenGL2Widget();
+	OpenGL2Widget();
+	~OpenGL2Widget() final;
 
-    QWidget *widget() override;
+	QWidget *widget() override final;
 
-    bool setVSync(bool enable) override;
-    void updateGL(bool requestDelayed) override;
+	bool setVSync(bool enable) override final;
+	void updateGL(bool requestDelayed) override final;
 
-    void initializeGL() override;
-    void paintGL() override;
+	void initializeGL() override final;
+	void paintGL() override final;
 private slots:
-    void aboutToBeDestroyed();
+	void aboutToBeDestroyed();
 private:
-    bool event(QEvent *e) override;
+	bool event(QEvent *e) override final;
 };
diff --git a/src/modules/OpenGL2/OpenGL2Window.cpp b/src/modules/OpenGL2/OpenGL2Window.cpp
index 14ae6a17..fe47a6ee 100644
--- a/src/modules/OpenGL2/OpenGL2Window.cpp
+++ b/src/modules/OpenGL2/OpenGL2Window.cpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "OpenGL2Window.hpp"
@@ -24,134 +24,134 @@
 #include <QDockWidget>
 
 OpenGL2Window::OpenGL2Window() :
-    visible(true)
+	visible(true)
 {
-    connect(&updateTimer, SIGNAL(timeout()), this, SLOT(doUpdateGL()));
+	connect(&updateTimer, SIGNAL(timeout()), this, SLOT(doUpdateGL()));
 
 #ifndef PASS_EVENTS_TO_PARENT
-    setFlags(Qt::WindowTransparentForInput);
+	setFlags(Qt::WindowTransparentForInput);
 #endif
 
-    container = QWidget::createWindowContainer(this);
-    container->setAttribute(Qt::WA_NativeWindow);
-    container->installEventFilter(this);
-    container->setAcceptDrops(false);
+	container = QWidget::createWindowContainer(this);
+	container->setAttribute(Qt::WA_NativeWindow);
+	container->installEventFilter(this);
+	container->setAcceptDrops(false);
 
-    connect(&QMPlay2Core, SIGNAL(videoDockVisible(bool)), this, SLOT(videoVisible(bool)));
+	connect(&QMPlay2Core, SIGNAL(videoDockVisible(bool)), this, SLOT(videoVisible(bool)));
 }
 OpenGL2Window::~OpenGL2Window()
 {
-    makeCurrent();
+	makeCurrent();
 }
 
 void OpenGL2Window::deleteMe()
 {
-    delete container;
+	delete container;
 }
 
 QWidget *OpenGL2Window::widget()
 {
-    return container;
+	return container;
 }
 
 bool OpenGL2Window::setVSync(bool enable)
 {
-    QSurfaceFormat fmt = format();
-    if (!handle())
-    {
-        fmt.setSwapBehavior(QSurfaceFormat::DoubleBuffer); //Probably it doesn't work
-        fmt.setSwapInterval(enable);
-        setFormat(fmt);
-    }
-    else if (enable != fmt.swapInterval())
-    {
-        fmt.setSwapInterval(enable);
-        destroy();
-        setFormat(fmt);
-        create();
-        setVisible(true);
-    }
-    vSync = enable;
-    return true;
+	QSurfaceFormat fmt = format();
+	if (!handle())
+	{
+		fmt.setSwapBehavior(QSurfaceFormat::DoubleBuffer); //Probably it doesn't work
+		fmt.setSwapInterval(enable);
+		setFormat(fmt);
+	}
+	else if (enable != fmt.swapInterval())
+	{
+		fmt.setSwapInterval(enable);
+		destroy();
+		setFormat(fmt);
+		create();
+		setVisible(true);
+	}
+	vSync = enable;
+	return true;
 }
 void OpenGL2Window::updateGL(bool requestDelayed)
 {
-    if (visible && isExposed())
-        QMetaObject::invokeMethod(this, "doUpdateGL", Qt::QueuedConnection, Q_ARG(bool, requestDelayed));
+	if (visible && isExposed())
+		QMetaObject::invokeMethod(this, "doUpdateGL", Qt::QueuedConnection, Q_ARG(bool, requestDelayed));
 }
 
 void OpenGL2Window::initializeGL()
 {
-    connect(context(), SIGNAL(aboutToBeDestroyed()), this, SLOT(aboutToBeDestroyed()), Qt::DirectConnection);
-    OpenGL2Common::initializeGL();
+	connect(context(), SIGNAL(aboutToBeDestroyed()), this, SLOT(aboutToBeDestroyed()), Qt::DirectConnection);
+	OpenGL2Common::initializeGL();
 }
 void OpenGL2Window::paintGL()
 {
-    if (isExposed())
-    {
-        glClear(GL_COLOR_BUFFER_BIT);
-        OpenGL2Common::paintGL();
-    }
+	if (isExposed())
+	{
+		glClear(GL_COLOR_BUFFER_BIT);
+		OpenGL2Common::paintGL();
+	}
 }
 
 void OpenGL2Window::doUpdateGL(bool queued)
 {
-    if (queued)
-        QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest), Qt::LowEventPriority);
-    else
-    {
-        //sendEvent() doesn't enqueue the event here
-        QEvent updateEvent(QEvent::UpdateRequest);
-        QCoreApplication::sendEvent(this, &updateEvent);
-    }
+	if (queued)
+		QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest), Qt::LowEventPriority);
+	else
+	{
+		//sendEvent() doesn't enqueue the event here
+		QEvent updateEvent(QEvent::UpdateRequest);
+		QCoreApplication::sendEvent(this, &updateEvent);
+	}
 }
 void OpenGL2Window::aboutToBeDestroyed()
 {
-    makeCurrent();
-    contextAboutToBeDestroyed();
-    doneCurrent();
+	makeCurrent();
+	contextAboutToBeDestroyed();
+	doneCurrent();
 }
 void OpenGL2Window::videoVisible(bool v)
 {
-    visible = v && (container->visibleRegion() != QRegion() || QMPlay2Core.getVideoDock()->visibleRegion() != QRegion());
+	visible = v && (container->visibleRegion() != QRegion() || QMPlay2Core.getVideoDock()->visibleRegion() != QRegion());
 }
 
 bool OpenGL2Window::eventFilter(QObject *o, QEvent *e)
 {
-    if (o == container)
-        dispatchEvent(e, container->parent());
-    return false;
+	if (o == container)
+		dispatchEvent(e, container->parent());
+	return false;
 }
 
 #ifdef PASS_EVENTS_TO_PARENT
 bool OpenGL2Window::event(QEvent *e)
 {
-    switch (e->type())
-    {
-        case QEvent::MouseButtonPress:
-        case QEvent::MouseButtonRelease:
-        case QEvent::MouseButtonDblClick:
-        case QEvent::MouseMove:
-        case QEvent::FocusIn:
-        case QEvent::FocusOut:
-        case QEvent::FocusAboutToChange:
-        case QEvent::Enter:
-        case QEvent::Leave:
-        case QEvent::Wheel:
-        case QEvent::TabletMove:
-        case QEvent::TabletPress:
-        case QEvent::TabletRelease:
-        case QEvent::TabletEnterProximity:
-        case QEvent::TabletLeaveProximity:
-        case QEvent::TouchBegin:
-        case QEvent::TouchUpdate:
-        case QEvent::TouchEnd:
-        case QEvent::InputMethodQuery:
-        case QEvent::TouchCancel:
-            return QCoreApplication::sendEvent(parent(), e);
-        default:
-            break;
-    }
-    return QOpenGLWindow::event(e);
+	switch (e->type())
+	{
+		case QEvent::MouseButtonPress:
+		case QEvent::MouseButtonRelease:
+		case QEvent::MouseButtonDblClick:
+		case QEvent::MouseMove:
+		case QEvent::FocusIn:
+		case QEvent::FocusOut:
+		case QEvent::FocusAboutToChange:
+		case QEvent::Enter:
+		case QEvent::Leave:
+		case QEvent::Wheel:
+		case QEvent::TabletMove:
+		case QEvent::TabletPress:
+		case QEvent::TabletRelease:
+		case QEvent::TabletEnterProximity:
+		case QEvent::TabletLeaveProximity:
+		case QEvent::TouchBegin:
+		case QEvent::TouchUpdate:
+		case QEvent::TouchEnd:
+		case QEvent::InputMethodQuery:
+		case QEvent::TouchCancel:
+			return QCoreApplication::sendEvent(parent(), e);
+		default:
+			break;
+	}
+	return QOpenGLWindow::event(e);
 }
 #endif
diff --git a/src/modules/OpenGL2/OpenGL2Window.hpp b/src/modules/OpenGL2/OpenGL2Window.hpp
index d9cbdf0b..50f13dc1 100644
--- a/src/modules/OpenGL2/OpenGL2Window.hpp
+++ b/src/modules/OpenGL2/OpenGL2Window.hpp
@@ -1,60 +1,60 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
 
-#include <OpenGL2Common.hpp>
+#include <OpenGL2CommonQt5.hpp>
 
 #include <QOpenGLWindow>
 #include <QWidget>
 
-#if defined Q_OS_MACOS || defined Q_OS_WIN //QTBUG-50505
-    #define PASS_EVENTS_TO_PARENT
+#if defined Q_OS_MAC || defined Q_OS_WIN //QTBUG-50505
+	#define PASS_EVENTS_TO_PARENT
 #endif
 
-class OpenGL2Window final : private QOpenGLWindow, public OpenGL2Common
+class OpenGL2Window : private QOpenGLWindow, public OpenGL2CommonQt5
 {
-    Q_OBJECT
+	Q_OBJECT
 public:
-    OpenGL2Window();
-    ~OpenGL2Window();
+	OpenGL2Window();
+	~OpenGL2Window() final;
 
-    void deleteMe() override;
+	void deleteMe() override final;
 
-    QWidget *widget() override;
+	QWidget *widget() override final;
 
-    bool setVSync(bool enable) override;
-    void updateGL(bool requestDelayed) override;
+	bool setVSync(bool enable) override final;
+	void updateGL(bool requestDelayed) override final;
 
-    void initializeGL() override;
-    void paintGL() override;
+	void initializeGL() override final;
+	void paintGL() override final;
 
 private slots:
-    void doUpdateGL(bool queued = false);
-    void aboutToBeDestroyed();
-    void videoVisible(bool v);
+	void doUpdateGL(bool queued = false);
+	void aboutToBeDestroyed();
+	void videoVisible(bool v);
 private:
-    bool eventFilter(QObject *o, QEvent *e) override;
+	bool eventFilter(QObject *o, QEvent *e) override final;
 
 #ifdef PASS_EVENTS_TO_PARENT
-    bool event(QEvent *e) override;
+	bool event(QEvent *e) override final;
 #endif
 
-    QWidget *container;
-    bool visible;
+	QWidget *container;
+	bool visible;
 };
diff --git a/src/modules/OpenGL2/OpenGL2Writer.cpp b/src/modules/OpenGL2/OpenGL2Writer.cpp
index 72fe4f70..f4d9cbf8 100644
--- a/src/modules/OpenGL2/OpenGL2Writer.cpp
+++ b/src/modules/OpenGL2/OpenGL2Writer.cpp
@@ -1,269 +1,257 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include <OpenGL2Writer.hpp>
 
-#include <OpenGL2Window.hpp>
-#include <OpenGL2Widget.hpp>
+#ifdef OPENGL_NEW_API
+	#include <OpenGL2Window.hpp>
+	#include <OpenGL2Widget.hpp>
+#else
+	#include <OpenGL2OldWidget.hpp>
+#endif
 
 #include <HWAccelInterface.hpp>
 #include <VideoFrame.hpp>
 
-#include <QGuiApplication>
+#ifdef OPENGL_NEW_API
+	#include <QGuiApplication>
+#endif
 
-OpenGL2Writer::OpenGL2Writer(Module &module)
-    : drawable(nullptr)
-    , allowPBO(true)
-    , forceRtt(false)
+OpenGL2Writer::OpenGL2Writer(Module &module) :
+	drawable(nullptr),
+	allowPBO(true)
+#ifdef OPENGL_NEW_API
+	, forceRtt(false)
+#endif
 {
-    addParam("W");
-    addParam("H");
-    addParam("AspectRatio");
-    addParam("Zoom");
-    addParam("Spherical");
-    addParam("Flip");
-    addParam("Rotate90");
-    addParam("ResetOther");
+	addParam("W");
+	addParam("H");
+	addParam("AspectRatio");
+	addParam("Zoom");
+	addParam("Spherical");
+	addParam("Flip");
+	addParam("Rotate90");
 
-    SetModule(module);
+	SetModule(module);
 }
 OpenGL2Writer::~OpenGL2Writer()
 {
-    if (drawable)
-        drawable->deleteMe();
+	if (drawable)
+		drawable->deleteMe();
 }
 
 bool OpenGL2Writer::set()
 {
-    bool doReset = false;
-
-    const bool newAllowPBO = sets().getBool("AllowPBO");
-    if (newAllowPBO != allowPBO)
-    {
-        allowPBO = newAllowPBO;
-        doReset = true;
-    }
-
-    const bool newHqScaling = sets().getBool("HQScaling");
-    if (newHqScaling != m_hqScaling)
-    {
-        m_hqScaling = newHqScaling;
-        doReset = true;
-    }
-
-    vSync = sets().getBool("VSync");
-    if (drawable && !drawable->setVSync(vSync))
-        doReset = true;
-
-    const bool newForceRtt = sets().getBool("ForceRtt");
-    if (forceRtt != newForceRtt)
-        doReset = true;
-    forceRtt = newForceRtt;
-
+	bool doReset = false;
+	bool newAllowPBO = sets().getBool("AllowPBO");
+	if (newAllowPBO != allowPBO)
+	{
+		allowPBO = newAllowPBO;
+		doReset = true;
+	}
+#ifdef VSYNC_SETTINGS
+	vSync = sets().getBool("VSync");
+	if (drawable && !drawable->setVSync(vSync))
+		doReset = true;
+#endif
+#ifdef OPENGL_NEW_API
+	bool newForceRtt = sets().getBool("ForceRtt");
+	if (forceRtt != newForceRtt)
+		doReset = true;
+	forceRtt = newForceRtt;
+#endif
 #ifdef Q_OS_WIN
-    bool newPreventFullScreen = sets().getBool("PreventFullScreen");
-    if (preventFullScreen != newPreventFullScreen)
-        doReset = true;
-    preventFullScreen = newPreventFullScreen;
+	bool newPreventFullScreen = sets().getBool("PreventFullScreen");
+	if (preventFullScreen != newPreventFullScreen)
+		doReset = true;
+	preventFullScreen = newPreventFullScreen;
 #endif
-
-    return !doReset && sets().getBool("Enabled");
+	return !doReset && sets().getBool("Enabled");
 }
 
 bool OpenGL2Writer::readyWrite() const
 {
-    return drawable->isOK;
+	return drawable->isOK;
 }
 
 bool OpenGL2Writer::hwAccelError() const
 {
-    return drawable->hwAccelError;
+	return drawable->hwAccelError;
 }
 
 bool OpenGL2Writer::processParams(bool *)
 {
-    bool doResizeEvent = false;
+	bool doResizeEvent = false;
 
-    const double aspectRatio = getParam("AspectRatio").toDouble();
-    const double zoom = getParam("Zoom").toDouble();
-    const bool spherical = getParam("Spherical").toBool();
-    const int flip = getParam("Flip").toInt();
-    const bool rotate90 = getParam("Rotate90").toBool();
+	const double aspectRatio = getParam("AspectRatio").toDouble();
+	const double zoom = getParam("Zoom").toDouble();
+	const bool spherical = getParam("Spherical").toBool();
+	const int flip = getParam("Flip").toInt();
+	const bool rotate90 = getParam("Rotate90").toBool();
 
-    const VideoAdjustment videoAdjustment = {
-        (qint16)getParam("Brightness").toInt(),
-        (qint16)getParam("Contrast").toInt(),
-        (qint16)getParam("Saturation").toInt(),
-        (qint16)getParam("Hue").toInt(),
-        (qint16)getParam("Sharpness").toInt()
-    };
+	const VideoAdjustment videoAdjustment = {
+		(qint16)getParam("Brightness").toInt(),
+		(qint16)getParam("Contrast").toInt(),
+		(qint16)getParam("Saturation").toInt(),
+		(qint16)getParam("Hue").toInt(),
+		(qint16)getParam("Sharpness").toInt()
+	};
 
-    const int verticesIdx = rotate90 * 4 + flip;
-    drawable->Deinterlace = getParam("Deinterlace").toInt();
-    if (drawable->aspectRatio != aspectRatio || drawable->zoom != zoom || drawable->sphericalView != spherical || drawable->verticesIdx != verticesIdx || drawable->videoAdjustment != videoAdjustment)
-    {
-        drawable->zoom = zoom;
-        drawable->aspectRatio = aspectRatio;
-        drawable->verticesIdx = verticesIdx;
-        drawable->videoAdjustment = videoAdjustment;
-        drawable->setSpherical(spherical);
-        doResizeEvent = drawable->widget()->isVisible();
-    }
-    if (getParam("ResetOther").toBool())
-    {
-        drawable->videoOffset = drawable->osdOffset = QPointF();
-        modParam("ResetOther", false);
-        if (!doResizeEvent)
-            doResizeEvent = drawable->widget()->isVisible();
-    }
+	const int verticesIdx = rotate90 * 4 + flip;
+	drawable->Deinterlace = getParam("Deinterlace").toInt();
+	if (drawable->aspectRatio != aspectRatio || drawable->zoom != zoom || drawable->sphericalView != spherical || drawable->verticesIdx != verticesIdx || drawable->videoAdjustment != videoAdjustment)
+	{
+		drawable->zoom = zoom;
+		drawable->aspectRatio = aspectRatio;
+		drawable->verticesIdx = verticesIdx;
+		drawable->videoAdjustment = videoAdjustment;
+		drawable->setSpherical(spherical);
+		doResizeEvent = drawable->widget()->isVisible();
+	}
 
-    const int outW = getParam("W").toInt();
-    const int outH = getParam("H").toInt();
-    if (outW != drawable->outW || outH != drawable->outH)
-    {
-        drawable->clearImg();
-        if (outW > 0 && outH > 0)
-        {
-            drawable->outW = outW;
-            drawable->outH = outH;
-        }
-        emit QMPlay2Core.dockVideo(drawable->widget());
-    }
+	const int outW = getParam("W").toInt();
+	const int outH = getParam("H").toInt();
+	if (outW != drawable->outW || outH != drawable->outH)
+	{
+		drawable->clearImg();
+		if (outW > 0 && outH > 0)
+		{
+			drawable->outW = outW;
+			drawable->outH = outH;
+		}
+		emit QMPlay2Core.dockVideo(drawable->widget());
+	}
 
-    if (doResizeEvent)
-        drawable->newSize();
-    else
-        drawable->doReset = true;
+	if (doResizeEvent)
+		drawable->newSize();
+	else
+		drawable->doReset = true;
 
-    return readyWrite();
+	return readyWrite();
 }
 
 QMPlay2PixelFormats OpenGL2Writer::supportedPixelFormats() const
 {
-    return {
-        QMPlay2PixelFormat::YUV420P,
-        QMPlay2PixelFormat::YUVJ420P,
-        QMPlay2PixelFormat::YUV422P,
-        QMPlay2PixelFormat::YUVJ422P,
-        QMPlay2PixelFormat::YUV444P,
-        QMPlay2PixelFormat::YUVJ444P,
-        QMPlay2PixelFormat::YUV410P,
-        QMPlay2PixelFormat::YUV411P,
-        QMPlay2PixelFormat::YUVJ411P,
-        QMPlay2PixelFormat::YUV440P,
-        QMPlay2PixelFormat::YUVJ440P,
-    };
+	return QMPlay2PixelFormats()
+			<< QMPlay2PixelFormat::YUV420P
+			<< QMPlay2PixelFormat::YUV422P
+			<< QMPlay2PixelFormat::YUV444P
+			<< QMPlay2PixelFormat::YUV410P
+			<< QMPlay2PixelFormat::YUV411P
+			<< QMPlay2PixelFormat::YUV440P
+	;
 }
 
 void OpenGL2Writer::writeVideo(const VideoFrame &videoFrame)
 {
-    drawable->isPaused = false;
-    drawable->videoFrame = videoFrame;
-    if (drawable->m_limited != drawable->videoFrame.limited || drawable->m_colorSpace != drawable->videoFrame.colorSpace)
-    {
-        drawable->m_limited = drawable->videoFrame.limited;
-        drawable->m_colorSpace = drawable->videoFrame.colorSpace;
-        drawable->doReset = true;
-    }
-    drawable->updateGL(drawable->sphericalView);
+	drawable->isPaused = false;
+	drawable->videoFrame = videoFrame;
+	drawable->updateGL(drawable->sphericalView);
 }
 void OpenGL2Writer::writeOSD(const QList<const QMPlay2OSD *> &osds)
 {
-    QMutexLocker mL(&drawable->osdMutex);
-    drawable->osdList = osds;
+	QMutexLocker mL(&drawable->osdMutex);
+	drawable->osdList = osds;
 }
 
 void OpenGL2Writer::setHWAccelInterface(HWAccelInterface *hwAccelInterface)
 {
-    addParam("Deinterlace");
-    addParam("PrepareForHWBobDeint", true);
-    VideoWriter::setHWAccelInterface(hwAccelInterface);
+	addParam("Deinterlace");
+	addParam("PrepareForHWBobDeint", true);
+	VideoWriter::setHWAccelInterface(hwAccelInterface);
 }
 
 void OpenGL2Writer::pause()
 {
-    drawable->isPaused = true;
+	drawable->isPaused = true;
 }
 
 QString OpenGL2Writer::name() const
 {
-    QString glStr = drawable->glVer ? QString("%1.%2").arg(drawable->glVer / 10).arg(drawable->glVer % 10) : "2";
-    if (drawable->hwAccellnterface)
-        glStr += " " + drawable->hwAccellnterface->name();
-    if (useRtt)
-        glStr += " (render-to-texture)";
+	QString glStr = drawable->glVer ? QString("%1.%2").arg(drawable->glVer / 10).arg(drawable->glVer % 10) : "2";
+	if (drawable->hwAccellnterface)
+		glStr += " " + drawable->hwAccellnterface->name();
+#ifdef OPENGL_NEW_API
+	if (useRtt)
+		glStr += " (render-to-texture)";
+#endif
 #ifdef OPENGL_ES2
-    return "OpenGL|ES " + glStr;
+	return "OpenGL|ES " + glStr;
 #else
-    return "OpenGL " + glStr;
+	return "OpenGL " + glStr;
 #endif
 }
 
 bool OpenGL2Writer::open()
 {
-    static const QString platformName = QGuiApplication::platformName();
-    useRtt = platformName.startsWith("wayland") || platformName == "android" || forceRtt;
-    if (useRtt)
-    {
-        //Don't use rtt when videoDock has native window
-        const QWidget *videoDock = QMPlay2Core.getVideoDock();
-        useRtt = !videoDock->internalWinId() || (videoDock == videoDock->window());
-    }
-    if (useRtt)
-        drawable = new OpenGL2Widget;
-    else
-        drawable = new OpenGL2Window;
-    drawable->hwAccellnterface = m_hwAccelInterface;
+#ifdef OPENGL_NEW_API
+	static const QString platformName = QGuiApplication::platformName();
+	useRtt = platformName == "wayland" || platformName == "android" || forceRtt;
+	if (useRtt)
+	{
+		//Don't use rtt when videoDock has native window
+		const QWidget *videoDock = QMPlay2Core.getVideoDock();
+		useRtt = !videoDock->internalWinId() || (videoDock == videoDock->window());
+	}
+	if (useRtt)
+		drawable = new OpenGL2Widget;
+	else
+		drawable = new OpenGL2Window;
+#else
+	drawable = new OpenGL2OldWidget;
+#endif
+	drawable->hwAccellnterface = m_hwAccelInterface;
 #ifdef Q_OS_WIN
-    drawable->preventFullScreen = preventFullScreen;
+	drawable->preventFullScreen = preventFullScreen;
+#endif
+	drawable->allowPBO = allowPBO;
+	if (drawable->testGL())
+	{
+#ifdef VSYNC_SETTINGS
+		drawable->setVSync(vSync);
 #endif
-    drawable->allowPBO = allowPBO;
-    drawable->hqScaling = m_hqScaling;
-    if (drawable->testGL())
-    {
-        drawable->setVSync(vSync);
-        bool hasBrightness = false, hasContrast = false, hasSharpness = false;
-        if (!drawable->videoAdjustmentKeys.isEmpty())
-        {
-            for (const QString &key : asConst(drawable->videoAdjustmentKeys))
-            {
-                if (key == "Brightness")
-                    hasBrightness = true;
-                else if (key == "Contrast")
-                    hasContrast = true;
-                else if (key == "Sharpness")
-                    hasSharpness = true;
-                addParam(key);
-            }
-        }
-        else if (drawable->numPlanes > 1)
-        {
-            addParam("Saturation");
-            if (drawable->canUseHueSharpness)
-                addParam("Hue");
-        }
-        if (!hasBrightness)
-            addParam("Brightness");
-        if (!hasContrast)
-            addParam("Contrast");
-        if (!hasSharpness && drawable->canUseHueSharpness)
-            addParam("Sharpness");
-        return true;
-    }
-    return false;
+		bool hasBrightness = false, hasContrast = false, hasSharpness = false;
+		if (!drawable->videoAdjustmentKeys.isEmpty())
+		{
+			for (const QString &key : drawable->videoAdjustmentKeys)
+			{
+				if (key == "Brightness")
+					hasBrightness = true;
+				else if (key == "Contrast")
+					hasContrast = true;
+				else if (key == "Sharpness")
+					hasSharpness = true;
+				addParam(key);
+			}
+		}
+		else if (drawable->numPlanes > 1)
+		{
+			addParam("Saturation");
+			if (drawable->canUseHueSharpness)
+				addParam("Hue");
+		}
+		if (!hasBrightness)
+			addParam("Brightness");
+		if (!hasContrast)
+			addParam("Contrast");
+		if (!hasSharpness && drawable->canUseHueSharpness)
+			addParam("Sharpness");
+		return true;
+	}
+	return false;
 }
diff --git a/src/modules/OpenGL2/OpenGL2Writer.hpp b/src/modules/OpenGL2/OpenGL2Writer.hpp
index 7881da78..58a5d259 100644
--- a/src/modules/OpenGL2/OpenGL2Writer.hpp
+++ b/src/modules/OpenGL2/OpenGL2Writer.hpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
@@ -24,44 +24,47 @@
 
 class OpenGL2Common;
 
-class OpenGL2Writer final : public VideoWriter
+class OpenGL2Writer : public VideoWriter
 {
-    Q_DECLARE_TR_FUNCTIONS(OpenGL2Writer)
+	Q_DECLARE_TR_FUNCTIONS(OpenGL2Writer)
 public:
-    OpenGL2Writer(Module &);
+	OpenGL2Writer(Module &);
 private:
-    ~OpenGL2Writer();
+	~OpenGL2Writer() final;
 
-    bool set() override;
+	bool set() override final;
 
-    bool readyWrite() const override;
+	bool readyWrite() const override final;
 
-    bool hwAccelError() const override;
+	bool hwAccelError() const override final;
 
-    bool processParams(bool *paramsCorrected) override;
+	bool processParams(bool *paramsCorrected) override final;
 
-    QMPlay2PixelFormats supportedPixelFormats() const override;
+	QMPlay2PixelFormats supportedPixelFormats() const override final;
 
-    void writeVideo(const VideoFrame &videoFrame) override;
-    void writeOSD(const QList<const QMPlay2OSD *> &) override;
+	void writeVideo(const VideoFrame &videoFrame) override final;
+	void writeOSD(const QList<const QMPlay2OSD *> &) override final;
 
-    void setHWAccelInterface(HWAccelInterface *hwAccelInterface) override;
+	void setHWAccelInterface(HWAccelInterface *hwAccelInterface) override final;
 
-    void pause() override;
+	void pause() override final;
 
-    QString name() const override;
+	QString name() const override final;
 
-    bool open() override;
+	bool open() override final;
 
-    /**/
+	/**/
 
-    OpenGL2Common *drawable;
-    bool allowPBO;
-    bool m_hqScaling = false;
-    bool forceRtt, useRtt;
-    bool vSync;
+	OpenGL2Common *drawable;
+	bool allowPBO;
+#ifdef OPENGL_NEW_API
+	bool forceRtt, useRtt;
+#endif
+#ifdef VSYNC_SETTINGS
+	bool vSync;
+#endif
 #ifdef Q_OS_WIN
-    bool preventFullScreen;
+	bool preventFullScreen;
 #endif
 };
 
diff --git a/src/modules/OpenGL2/Sphere.cpp b/src/modules/OpenGL2/Sphere.cpp
index adcb4ba2..4dcefbd6 100644
--- a/src/modules/OpenGL2/Sphere.cpp
+++ b/src/modules/OpenGL2/Sphere.cpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "Sphere.hpp"
@@ -22,35 +22,35 @@
 
 quint32 Sphere::getSizes(quint32 slices, quint32 stacks, quint32 &verticesSize, quint32 &texcoordsSize, quint32 &indicesSize)
 {
-    verticesSize  = slices * stacks * 3 * sizeof(float);
-    texcoordsSize = slices * stacks * 2 * sizeof(float);
-    indicesSize   = slices * stacks * 2 * sizeof(quint16);
-    return indicesSize / sizeof(quint16);
+	verticesSize  = slices * stacks * 3 * sizeof(float);
+	texcoordsSize = slices * stacks * 2 * sizeof(float);
+	indicesSize   = slices * stacks * 2 * sizeof(quint16);
+	return indicesSize / sizeof(quint16);
 }
 void Sphere::generate(float radius, quint32 slices, quint32 stacks, float *vertices, float *texcoords, quint16 *indices)
 {
-    const double iStacks = 1.0 / (stacks - 1.0);
-    const double iSlices = 1.0 / (slices - 1.0);
-    for (quint32 stack = 0; stack < stacks; ++stack)
-    {
-        for (quint32 slice = 0; slice < slices; ++slice)
-        {
-            const double theta = stack * M_PI * iStacks;
-            const double phi = slice * 2.0 * M_PI * iSlices;
-            const double sinTheta = sin(theta);
-            const double cosTheta = cos(theta);
-            const double sinPhi = sin(phi);
-            const double cosPhi = cos(phi);
-
-            *(vertices++) = radius * cosPhi * sinTheta;
-            *(vertices++) = radius * sinPhi * sinTheta;
-            *(vertices++) = radius * cosTheta;
-
-            *(texcoords++) = slice * iSlices;
-            *(texcoords++) = (stacks - stack - 1) * iStacks;
-
-            *(indices++) = (stack + 0) * slices + slice;
-            *(indices++) = (stack + 1) * slices + slice;
-        }
-    }
+	const double iStacks = 1.0 / (stacks - 1.0);
+	const double iSlices = 1.0 / (slices - 1.0);
+	for (quint32 stack = 0; stack < stacks; ++stack)
+	{
+		for (quint32 slice = 0; slice < slices; ++slice)
+		{
+			const double theta = stack * M_PI * iStacks;
+			const double phi = slice * 2.0 * M_PI * iSlices;
+			const double sinTheta = sin(theta);
+			const double cosTheta = cos(theta);
+			const double sinPhi = sin(phi);
+			const double cosPhi = cos(phi);
+
+			*(vertices++) = radius * cosPhi * sinTheta;
+			*(vertices++) = radius * sinPhi * sinTheta;
+			*(vertices++) = radius * cosTheta;
+
+			*(texcoords++) = slice * iSlices;
+			*(texcoords++) = (stacks - stack - 1) * iStacks;
+
+			*(indices++) = (stack + 0) * slices + slice;
+			*(indices++) = (stack + 1) * slices + slice;
+		}
+	}
 }
diff --git a/src/modules/OpenGL2/Sphere.hpp b/src/modules/OpenGL2/Sphere.hpp
index de0a8022..4806bf73 100644
--- a/src/modules/OpenGL2/Sphere.hpp
+++ b/src/modules/OpenGL2/Sphere.hpp
@@ -1,19 +1,19 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
@@ -22,6 +22,6 @@
 
 namespace Sphere
 {
-    quint32 getSizes(quint32 slices, quint32 stacks, quint32 &verticesSize, quint32 &texcoordsSize, quint32 &indicesSize);
-    void generate(float radius, quint32 slices, quint32 stacks, float *vertices, float *texcoords, quint16 *indices);
+	quint32 getSizes(quint32 slices, quint32 stacks, quint32 &verticesSize, quint32 &texcoordsSize, quint32 &indicesSize);
+	void generate(float radius, quint32 slices, quint32 stacks, float *vertices, float *texcoords, quint16 *indices);
 }
diff --git a/src/modules/OpenGL2/Vertices.hpp b/src/modules/OpenGL2/Vertices.hpp
index 3d926237..7fd76e14 100644
--- a/src/modules/OpenGL2/Vertices.hpp
+++ b/src/modules/OpenGL2/Vertices.hpp
@@ -1,85 +1,85 @@
 /*
-    QMPlay2 is a video and audio player.
-    Copyright (C) 2010-2019  Błażej Szczygieł
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2017  Błażej Szczygieł
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #pragma once
 
 constexpr float verticesYCbCr[8][8] = {
-    /* Normal */
-    {
-        -1.0f, -1.0f, //0. Left-bottom
-        +1.0f, -1.0f, //1. Right-bottom
-        -1.0f, +1.0f, //2. Left-top
-        +1.0f, +1.0f, //3. Right-top
-    },
-    /* Horizontal flip */
-    {
-        +1.0f, -1.0f, //1. Right-bottom
-        -1.0f, -1.0f, //0. Left-bottom
-        +1.0f, +1.0f, //3. Right-top
-        -1.0f, +1.0f, //2. Left-top
-    },
-    /* Vertical flip */
-    {
-        -1.0f, +1.0f, //2. Left-top
-        +1.0f, +1.0f, //3. Right-top
-        -1.0f, -1.0f, //0. Left-bottom
-        +1.0f, -1.0f, //1. Right-bottom
-    },
-    /* Rotated 180 */
-    {
-        +1.0f, +1.0f, //3. Right-top
-        -1.0f, +1.0f, //2. Left-top
-        +1.0f, -1.0f, //1. Right-bottom
-        -1.0f, -1.0f, //0. Left-bottom
-    },
+	/* Normal */
+	{
+		-1.0f, -1.0f, //0. Left-bottom
+		+1.0f, -1.0f, //1. Right-bottom
+		-1.0f, +1.0f, //2. Left-top
+		+1.0f, +1.0f, //3. Right-top
+	},
+	/* Horizontal flip */
+	{
+		+1.0f, -1.0f, //1. Right-bottom
+		-1.0f, -1.0f, //0. Left-bottom
+		+1.0f, +1.0f, //3. Right-top
+		-1.0f, +1.0f, //2. Left-top
+	},
+	/* Vertical flip */
+	{
+		-1.0f, +1.0f, //2. Left-top
+		+1.0f, +1.0f, //3. Right-top
+		-1.0f, -1.0f, //0. Left-bottom
+		+1.0f, -1.0f, //1. Right-bottom
+	},
+	/* Rotated 180 */
+	{
+		+1.0f, +1.0f, //3. Right-top
+		-1.0f, +1.0f, //2. Left-top
+		+1.0f, -1.0f, //1. Right-bottom
+		-1.0f, -1.0f, //0. Left-bottom
+	},
 
-    /* Rotated 90 */
-    {
-        -1.0f, +1.0f, //2. Left-top
-        -1.0f, -1.0f, //0. Left-bottom
-        +1.0f, +1.0f, //3. Right-top
-        +1.0f, -1.0f, //1. Right-bottom
-    },
-    /* Rotated 90 + horizontal flip */
-    {
-        +1.0f, +1.0f, //3. Right-top
-        +1.0f, -1.0f, //1. Right-bottom
-        -1.0f, +1.0f, //2. Left-top
-        -1.0f, -1.0f, //0. Left-bottom
-    },
-    /* Rotated 90 + vertical flip */
-    {
-        -1.0f, -1.0f, //0. Left-bottom
-        -1.0f, +1.0f, //2. Left-top
-        +1.0f, -1.0f, //1. Right-bottom
-        +1.0f, +1.0f, //3. Right-top
-    },
-    /* Rotated 270 */
-    {
-        +1.0f, -1.0f, //1. Right-bottom
-        +1.0f, +1.0f, //3. Right-top
-        -1.0f, -1.0f, //0. Left-bottom
-        -1.0f, +1.0f, //2. Left-top
-    },
+	/* Rotated 90 */
+	{
+		-1.0f, +1.0f, //2. Left-top
+		-1.0f, -1.0f, //0. Left-bottom
+		+1.0f, +1.0f, //3. Right-top
+		+1.0f, -1.0f, //1. Right-bottom
+	},
+	/* Rotated 90 + horizontal flip */
+	{
+		+1.0f, +1.0f, //3. Right-top
+		+1.0f, -1.0f, //1. Right-bottom
+		-1.0f, +1.0f, //2. Left-top
+		-1.0f, -1.0f, //0. Left-bottom
+	},
+	/* Rotated 90 + vertical flip */
+	{
+		-1.0f, -1.0f, //0. Left-bottom
+		-1.0f, +1.0f, //2. Left-top
+		+1.0f, -1.0f, //1. Right-bottom
+		+1.0f, +1.0f, //3. Right-top
+	},
+	/* Rotated 270 */
+	{
+		+1.0f, -1.0f, //1. Right-bottom
+		+1.0f, +1.0f, //3. Right-top
+		-1.0f, -1.0f, //0. Left-bottom
+		-1.0f, +1.0f, //2. Left-top
+	},
 };
 constexpr float texCoordOSD[8] = {
-    0.0f, 1.0f,
-    1.0f, 1.0f,
-    0.0f, 0.0f,
-    1.0f, 0.0f,
+	0.0f, 1.0f,
+	1.0f, 1.0f,
+	0.0f, 0.0f,
+	1.0f, 0.0f,
 };
diff --git a/src/modules/OpenGL2/res.qrc b/src/modules/OpenGL2/res.qrc
deleted file mode 100644
index 9a38ede7..00000000
--- a/src/modules/OpenGL2/res.qrc
+++ /dev/null
@@ -1,13 +0,0 @@
-<RCC>
-    <qresource>
-        <file alias="OpenGL2.svgz">OpenGL2.svgz</file>
-
-        <file alias="Video.vert">GLSL/Video.vert</file>
-        <file alias="Bicubic.frag">GLSL/Bicubic.frag</file>
-        <file alias="VideoYCbCr.frag">GLSL/VideoYCbCr.frag</file>
-        <file alias="VideoRGB.frag">GLSL/VideoRGB.frag</file>
-
-        <file alias="OSD.vert">GLSL/OSD.vert</file>
-        <file alias="OSD.frag">GLSL/OSD.frag</file>
-    </qresource>
-</RCC>
diff --git a/src/modules/OpenGL2/resources.qrc b/src/modules/OpenGL2/resources.qrc
new file mode 100644
index 00000000..75f3968a
--- /dev/null
+++ b/src/modules/OpenGL2/resources.qrc
@@ -0,0 +1,12 @@
+<RCC>
+	<qresource>
+		<file alias="OpenGL2.svgz">OpenGL2.svgz</file>
+
+		<file alias="Video.vert">GLSL/Video.vert</file>
+		<file alias="VideoYCbCr.frag">GLSL/VideoYCbCr.frag</file>
+		<file alias="VideoRGB.frag">GLSL/VideoRGB.frag</file>
+
+		<file alias="OSD.vert">GLSL/OSD.vert</file>
+		<file alias="OSD.frag">GLSL/OSD.frag</file>
+	</qresource>
+</RCC>
-- 
2.48.0

